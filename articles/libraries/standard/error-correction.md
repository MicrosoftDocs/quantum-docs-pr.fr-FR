---
title: 'Q # bibliothèques standard-correction des erreurs | Microsoft Docs'
description: 'Bibliothèques standard Q #-correction d’erreur'
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 5aac40686ba9b45a51e0274a1828f2ff7cce6fc3
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/27/2019
ms.locfileid: "73184438"
---
# <a name="error-correction"></a><span data-ttu-id="94b40-103">Correction des erreurs</span><span class="sxs-lookup"><span data-stu-id="94b40-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="94b40-104">Présentation</span><span class="sxs-lookup"><span data-stu-id="94b40-104">Introduction</span></span> ##

<span data-ttu-id="94b40-105">Dans le calcul classique, si l’un d’eux veut protéger un peu contre les erreurs, il peut souvent suffire de représenter ce bit par un *bit logique* en répétant le bit de données.</span><span class="sxs-lookup"><span data-stu-id="94b40-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="94b40-106">Par exemple, laissez $ \overline{0} = $0 correspond à l’encodage du bit de données 0, où nous utilisons la ligne a au-dessus de l’étiquette 0 pour indiquer qu’il s’agit d’un encodage d’un bit dans l’État 0.</span><span class="sxs-lookup"><span data-stu-id="94b40-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="94b40-107">Si nous commençons de la même façon que $ \overline{1} = $111, nous disposons d’un code de répétition simple qui protège contre toute erreur d’inversion d’un bit.</span><span class="sxs-lookup"><span data-stu-id="94b40-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="94b40-108">Autrement dit, si l’un des trois bits est retourné, vous pouvez récupérer l’état du bit logique en prenant un vote majoritaire.</span><span class="sxs-lookup"><span data-stu-id="94b40-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="94b40-109">Même si la correction d’erreur classique est un sujet bien plus riche que cet exemple particulier (nous recommandons la présentation de la [théorie du codage de Lint](https://www.springer.com/us/book/9783540641339)), le code de répétition ci-dessus pointe déjà vers un problème possible pour la protection des informations de Quantum.</span><span class="sxs-lookup"><span data-stu-id="94b40-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="94b40-110">À savoir, le titre de [non-clonage](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implique que si nous mesurons chaque qubit individuel et que nous prenons un vote majoritaire par analogie au code classique ci-dessus, nous avons perdu les informations précises que nous essayons de protéger.</span><span class="sxs-lookup"><span data-stu-id="94b40-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="94b40-111">Dans le paramètre Quantum, nous voyons que la mesure est problématique.</span><span class="sxs-lookup"><span data-stu-id="94b40-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="94b40-112">Nous pouvons toujours implémenter l’encodage ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="94b40-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="94b40-113">Il est utile de le faire pour voir comment vous pouvez généraliser la correction des erreurs dans le cas Quantum.</span><span class="sxs-lookup"><span data-stu-id="94b40-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="94b40-114">Par conséquent, laissez $ \ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$ et laissez $ \ket{\overline{1}} = \ket{111}$.</span><span class="sxs-lookup"><span data-stu-id="94b40-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="94b40-115">Ensuite, par linéarité, nous avons défini notre code de répétition pour toutes les entrées ; par exemple, $ \ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}})/\sqrt{2} = (\ket{000} + \ket{111})/\sqrt{2}$.</span><span class="sxs-lookup"><span data-stu-id="94b40-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="94b40-116">En particulier, si vous laissez une erreur de retournement de bit $X _ 1 $ agir sur le qubit du milieu, nous constatons que la correction nécessaire dans les deux branches est précise $X _ 1 $ : $ $ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left (X_1 \ket{000} + X_1 \ket @no__ t_3_ \right) \\\\ & = \frac{1}{\sqrt{2}} \left (\ket{010} + \ket{101} \right).</span><span class="sxs-lookup"><span data-stu-id="94b40-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="94b40-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="94b40-117">\end{align} $$</span></span>

<span data-ttu-id="94b40-118">Pour voir comment nous pouvons déterminer que c’est le cas sans mesurer le tout l’état que nous tentons de protéger, il est utile de noter ce que fait chaque erreur de retournement de bits vers nos États logiques :</span><span class="sxs-lookup"><span data-stu-id="94b40-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="94b40-119">Erreur $E $</span><span class="sxs-lookup"><span data-stu-id="94b40-119">Error $E$</span></span> | <span data-ttu-id="94b40-120">$E \ket{\overline{0}} $</span><span class="sxs-lookup"><span data-stu-id="94b40-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="94b40-121">$E \ket{\overline{1}} $</span><span class="sxs-lookup"><span data-stu-id="94b40-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="94b40-122">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="94b40-122">$\boldone$</span></span> | <span data-ttu-id="94b40-123">$ \ket{000}$</span><span class="sxs-lookup"><span data-stu-id="94b40-123">$\ket{000}$</span></span> | <span data-ttu-id="94b40-124">$ \ket{111}$</span><span class="sxs-lookup"><span data-stu-id="94b40-124">$\ket{111}$</span></span> |
| <span data-ttu-id="94b40-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="94b40-125">$X_0$</span></span> | <span data-ttu-id="94b40-126">$ \ket{100}$</span><span class="sxs-lookup"><span data-stu-id="94b40-126">$\ket{100}$</span></span> | <span data-ttu-id="94b40-127">$ \ket{011}$</span><span class="sxs-lookup"><span data-stu-id="94b40-127">$\ket{011}$</span></span> |
| <span data-ttu-id="94b40-128">$X _ 1 $</span><span class="sxs-lookup"><span data-stu-id="94b40-128">$X_1$</span></span> | <span data-ttu-id="94b40-129">$ \ket{010}$</span><span class="sxs-lookup"><span data-stu-id="94b40-129">$\ket{010}$</span></span> | <span data-ttu-id="94b40-130">$ \ket{101}$</span><span class="sxs-lookup"><span data-stu-id="94b40-130">$\ket{101}$</span></span> |
| <span data-ttu-id="94b40-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="94b40-131">$X_2$</span></span> | <span data-ttu-id="94b40-132">$ \ket{001}$</span><span class="sxs-lookup"><span data-stu-id="94b40-132">$\ket{001}$</span></span> | <span data-ttu-id="94b40-133">$ \ket{110}$</span><span class="sxs-lookup"><span data-stu-id="94b40-133">$\ket{110}$</span></span> |

<span data-ttu-id="94b40-134">Pour protéger l’état d’encodage, nous devons être en mesure de distinguer les trois erreurs les unes des autres et de l’identité $ \boldone $ sans faire la distinction entre $ \ket{\overline{0}} $ et $ \ket{\overline{1}} $.</span><span class="sxs-lookup"><span data-stu-id="94b40-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="94b40-135">Par exemple, si nous mesurons $Z _0 $, nous obtenons un résultat différent pour $ \ket{\overline{0}} $ et $ \ket{\overline{1}} $ dans le cas de non-erreur, afin de réduire l’État encodé.</span><span class="sxs-lookup"><span data-stu-id="94b40-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="94b40-136">En revanche, envisagez de mesurer $Z _0 Z_1 $, la parité des deux premiers bits dans chaque État de base de calcul.</span><span class="sxs-lookup"><span data-stu-id="94b40-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="94b40-137">Rappelez-vous que chaque mesure d’un opérateur Pauli vérifie les eigenvalue l’État mesuré correspond à. donc, pour chaque État $ \ket{\Psi} $ dans le tableau ci-dessus, nous pouvons calculer $Z _0 Z_1 \ket{\Psi} $ pour voir si nous obtenons $ \pm\ket{\Psi} $.</span><span class="sxs-lookup"><span data-stu-id="94b40-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="94b40-138">Notez que $Z _0 Z_1 \ket{000} = \ket{000}$ et que $Z _0 Z_1 \ket{111} = \ket{111}$, nous concluons que cette mesure fait la même chose pour les deux États encodés.</span><span class="sxs-lookup"><span data-stu-id="94b40-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="94b40-139">En revanche, $Z _0 Z_1 \ket{100} =-\ket{100}$ et $Z _0 Z_1 \ket{011} =-\ket{011}$, le résultat de la mesure de $Z _0 Z_1 $ révèle des informations utiles sur l’erreur qui s’est produite.</span><span class="sxs-lookup"><span data-stu-id="94b40-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occured.</span></span>

<span data-ttu-id="94b40-140">Pour souligner cela, nous répétons le tableau ci-dessus, mais nous ajoutons les résultats de la mesure $Z _0 Z_1 $ et $Z _ 1 Z_2 $ sur chaque ligne.</span><span class="sxs-lookup"><span data-stu-id="94b40-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="94b40-141">Nous désignons les résultats de chaque mesure par le signe du eigenvalue observé, $ + $ ou $-$, correspondant aux valeurs Q # `Result` de `Zero` et de `One`, respectivement.</span><span class="sxs-lookup"><span data-stu-id="94b40-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="94b40-142">Erreur $E $</span><span class="sxs-lookup"><span data-stu-id="94b40-142">Error $E$</span></span> | <span data-ttu-id="94b40-143">$E \ket{\overline{0}} $</span><span class="sxs-lookup"><span data-stu-id="94b40-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="94b40-144">$E \ket{\overline{1}} $</span><span class="sxs-lookup"><span data-stu-id="94b40-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="94b40-145">Résultat de $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="94b40-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="94b40-146">Résultat de $Z _ 1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="94b40-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="94b40-147">$ \boldone $</span><span class="sxs-lookup"><span data-stu-id="94b40-147">$\boldone$</span></span> | <span data-ttu-id="94b40-148">$ \ket{000}$</span><span class="sxs-lookup"><span data-stu-id="94b40-148">$\ket{000}$</span></span> | <span data-ttu-id="94b40-149">$ \ket{111}$</span><span class="sxs-lookup"><span data-stu-id="94b40-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="94b40-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="94b40-150">$X_0$</span></span> | <span data-ttu-id="94b40-151">$ \ket{100}$</span><span class="sxs-lookup"><span data-stu-id="94b40-151">$\ket{100}$</span></span> | <span data-ttu-id="94b40-152">$ \ket{011}$</span><span class="sxs-lookup"><span data-stu-id="94b40-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="94b40-153">$X _ 1 $</span><span class="sxs-lookup"><span data-stu-id="94b40-153">$X_1$</span></span> | <span data-ttu-id="94b40-154">$ \ket{010}$</span><span class="sxs-lookup"><span data-stu-id="94b40-154">$\ket{010}$</span></span> | <span data-ttu-id="94b40-155">$ \ket{101}$</span><span class="sxs-lookup"><span data-stu-id="94b40-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="94b40-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="94b40-156">$X_2$</span></span> | <span data-ttu-id="94b40-157">$ \ket{001}$</span><span class="sxs-lookup"><span data-stu-id="94b40-157">$\ket{001}$</span></span> | <span data-ttu-id="94b40-158">$ \ket{110}$</span><span class="sxs-lookup"><span data-stu-id="94b40-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="94b40-159">Ainsi, les résultats des deux mesures déterminent de manière unique l’erreur de retournement de bits qui s’est produite, mais sans révéler d’informations sur l’état que nous envoyons.</span><span class="sxs-lookup"><span data-stu-id="94b40-159">Thus, the results of the two measurements uniquely determines which bit-flip error occured, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="94b40-160">Nous appelons ces résultats un *syndrome*et revenons au processus de mappage d’un syndrome à l’erreur qui l’a provoquée comme *récupération*.</span><span class="sxs-lookup"><span data-stu-id="94b40-160">We call these results a *syndrome*, and refer to the process of mapping a syndrome back to the error that caused it as *recovery*.</span></span>
<span data-ttu-id="94b40-161">En particulier, nous insistons sur le fait que la récupération est une procédure d’inférence *classique* qui prend comme entrée le syndrome qui s’est produit, et retourne une prescription pour la résolution des erreurs qui se sont produites.</span><span class="sxs-lookup"><span data-stu-id="94b40-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occured, and returns a prescription for how to fix any errors that may have occured.</span></span>

> [!NOTE]
> <span data-ttu-id="94b40-162">Le code d’inversion de bits ci-dessus peut être corrigé uniquement par rapport à des erreurs à inversion de bit. autrement dit, une opération `X` agissant sur un seul qubit.</span><span class="sxs-lookup"><span data-stu-id="94b40-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="94b40-163">L’application d' `X` à plusieurs qubit mappera $ \ket{\overline{0}} $ à $ \ket{\overline{1}} $ après la récupération.</span><span class="sxs-lookup"><span data-stu-id="94b40-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="94b40-164">De même, l’application d’une opération de basculement de phase `Z` mappera $ \ket{\overline{1}} $ à $-\ket{\overline{1}} $, et mappera donc $ \ket{\overline{+}} $ à $ \ket{\overline{-}} $.</span><span class="sxs-lookup"><span data-stu-id="94b40-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="94b40-165">Plus généralement, il est possible de créer des codes pour gérer le plus grand nombre d’erreurs et de gérer les erreurs de $Z $, ainsi que les erreurs $X $.</span><span class="sxs-lookup"><span data-stu-id="94b40-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="94b40-166">L’information qui nous permet de décrire les mesures de correction des erreurs Quantum qui agissent de la même manière sur tous les États de code est l’Essen du *formalisme du stabilisant*.</span><span class="sxs-lookup"><span data-stu-id="94b40-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essense of the *stabilizer formalism*.</span></span>
<span data-ttu-id="94b40-167">Le moteur Q # Canon fournit une infrastructure pour décrire l’encodage et le décodage à partir de codes stabilisants, et pour décrire la façon dont l’un récupère des erreurs.</span><span class="sxs-lookup"><span data-stu-id="94b40-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="94b40-168">Dans cette section, nous décrivons cette infrastructure et son application à quelques codes de correction des erreurs Quantum simples.</span><span class="sxs-lookup"><span data-stu-id="94b40-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="94b40-169">Une introduction complète au formalisme du stabilisateur dépasse le cadre de cette section.</span><span class="sxs-lookup"><span data-stu-id="94b40-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="94b40-170">Nous faisons référence aux lecteurs qui souhaitent en savoir plus sur [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span><span class="sxs-lookup"><span data-stu-id="94b40-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-q"></a><span data-ttu-id="94b40-171">Représentation des codes de correction des erreurs dans Q #</span><span class="sxs-lookup"><span data-stu-id="94b40-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="94b40-172">Pour vous aider à spécifier les codes de correction des erreurs, le moteur Q # Canon fournit plusieurs types définis par l’utilisateur distincts :</span><span class="sxs-lookup"><span data-stu-id="94b40-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="94b40-173"><xref:microsoft.quantum.errorcorrection.logicalregister> `= Qubit[]`: indique qu’un registre de qubits doit être interprété comme le bloc de code d’un code de correction des erreurs.</span><span class="sxs-lookup"><span data-stu-id="94b40-173"><xref:microsoft.quantum.errorcorrection.logicalregister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="94b40-174"><xref:microsoft.quantum.errorcorrection.syndrome> `= Result[]`: indique qu’un tableau de résultats de mesure doit être interprété comme le syndrome mesuré sur un bloc de code.</span><span class="sxs-lookup"><span data-stu-id="94b40-174"><xref:microsoft.quantum.errorcorrection.syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="94b40-175"><xref:microsoft.quantum.errorcorrection.recoveryfn> `= (Syndrome -> Pauli[])`: indique qu’une fonction *classique* doit être utilisée pour interpréter un syndrome et retourner une correction qui doit être appliquée.</span><span class="sxs-lookup"><span data-stu-id="94b40-175"><xref:microsoft.quantum.errorcorrection.recoveryfn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="94b40-176"><xref:microsoft.quantum.errorcorrection.encodeop> `= ((Qubit[], Qubit[]) => LogicalRegister)`: indique qu’une opération prend qubits représentant des données avec des qubits de Ancilla actualisés afin de produire un bloc de code d’un code de correction des erreurs.</span><span class="sxs-lookup"><span data-stu-id="94b40-176"><xref:microsoft.quantum.errorcorrection.encodeop> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="94b40-177"><xref:microsoft.quantum.errorcorrection.decodeop> `= (LogicalRegister => (Qubit[], Qubit[]))`: indique qu’une opération décompose un bloc de code d’une erreur de correction du code dans le qubits de données et le qubits Ancilla utilisé pour représenter les informations de syndrome.</span><span class="sxs-lookup"><span data-stu-id="94b40-177"><xref:microsoft.quantum.errorcorrection.decodeop> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="94b40-178"><xref:microsoft.quantum.errorcorrection.syndromemeasop> `= (LogicalRegister => Syndrome)`: désigne une opération qui doit être utilisée pour extraire les informations de syndrome d’un bloc de code, sans perturber l’État protégé par le code.</span><span class="sxs-lookup"><span data-stu-id="94b40-178"><xref:microsoft.quantum.errorcorrection.syndromemeasop> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="94b40-179">Enfin, Canon fournit le type de <xref:microsoft.quantum.errorcorrection.qecc> pour collecter les autres types requis pour définir un code de correction des erreurs Quantum.</span><span class="sxs-lookup"><span data-stu-id="94b40-179">Finally, the canon provides the <xref:microsoft.quantum.errorcorrection.qecc> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="94b40-180">La longueur du code est associée à chaque code de Quantum stabilisateur $n $, le nombre $k $ de l’qubits logique et la distance minimale $d $, souvent regroupées dans la notation ⟦ $n $, $k $, $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="94b40-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="94b40-181">Par exemple, la fonction <xref:microsoft.quantum.errorcorrection.bitflipcode> définit le code d’inversion ⟦ 3, 1, 1 ⟧ bit :</span><span class="sxs-lookup"><span data-stu-id="94b40-181">For example, the <xref:microsoft.quantum.errorcorrection.bitflipcode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="94b40-182">Notez que le type de `QECC` n’inclut *pas* de fonction de récupération.</span><span class="sxs-lookup"><span data-stu-id="94b40-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="94b40-183">Cela nous permet de modifier la fonction de récupération utilisée pour corriger les erreurs sans modifier la définition du code lui-même. Cette fonctionnalité est particulièrement utile lors de l’incorporation de commentaires à partir de mesures de caractérisation dans le modèle supposé par la récupération.</span><span class="sxs-lookup"><span data-stu-id="94b40-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="94b40-184">Une fois qu’un code est défini de cette manière, nous pouvons utiliser l’opération <xref:microsoft.quantum.errorcorrection.recover> pour récupérer des erreurs :</span><span class="sxs-lookup"><span data-stu-id="94b40-184">Once a code is defined in this way, we can use the <xref:microsoft.quantum.errorcorrection.recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="94b40-185">Nous explorons ceci plus en détail dans l' [exemple de code de symétrie de bit](https://github.com/Microsoft/Quantum/tree/master/Samples/src/BitFlipCode).</span><span class="sxs-lookup"><span data-stu-id="94b40-185">We explore this in more detail in the [bit flip code sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/BitFlipCode).</span></span>

<span data-ttu-id="94b40-186">Hormis le code d’inversion de bits, le moteur Q # Canon est fourni avec les implémentations du [code parfait qubit](https://arxiv.org/abs/1305.08)et du [Code de sept qubit](https://arxiv.org/abs/quant-ph/9705052), qui peuvent corriger une erreur de qubit unique arbitraire.</span><span class="sxs-lookup"><span data-stu-id="94b40-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/1305.08), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
