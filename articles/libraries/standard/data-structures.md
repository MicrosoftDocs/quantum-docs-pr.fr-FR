---
title: 'Bibliothèques standard Q #-structures de données | Microsoft Docs'
description: 'Bibliothèques standard Q #-structures de données'
author: QuantumWriter
uid: microsoft.quantum.libraries.data-structures
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: e8b28561f1aba37cb5bf41c6176386d19bfacf06
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/27/2019
ms.locfileid: "73184506"
---
# <a name="data-structures-and-modeling"></a><span data-ttu-id="315cb-103">Structures de données et modélisation</span><span class="sxs-lookup"><span data-stu-id="315cb-103">Data Structures and Modeling</span></span> #

## <a name="classical-data-structures"></a><span data-ttu-id="315cb-104">Structures de données classiques</span><span class="sxs-lookup"><span data-stu-id="315cb-104">Classical Data Structures</span></span> ##

<span data-ttu-id="315cb-105">Outre les types définis par l’utilisateur pour représenter les concepts de Quantum, Canon fournit également des opérations, des fonctions et des types pour l’utilisation des données classiques utilisées dans le contrôle des systèmes quantiques.</span><span class="sxs-lookup"><span data-stu-id="315cb-105">Along with user-defined types for representing quantum concepts, the canon also provides operations, functions, and types for working with classical data used in the control of quantum systems.</span></span>
<span data-ttu-id="315cb-106">Par exemple, la fonction <xref:microsoft.quantum.arrays.reversed> prend un tableau comme entrée et retourne le même tableau dans l’ordre inverse.</span><span class="sxs-lookup"><span data-stu-id="315cb-106">For instance, the <xref:microsoft.quantum.arrays.reversed> function takes an array as input and returns the same array in reverse order.</span></span>
<span data-ttu-id="315cb-107">Il peut ensuite être utilisé sur un tableau de type `Qubit[]` pour éviter d’avoir à appliquer des portes $ \operatorname{SWAP} $ inutiles lors de la conversion entre des représentations quantiques d’entiers.</span><span class="sxs-lookup"><span data-stu-id="315cb-107">This can then be used on an array of type `Qubit[]` to avoid having to apply unnecessary $\operatorname{SWAP}$ gates when converting between quantum representations of integers.</span></span>
<span data-ttu-id="315cb-108">De même, nous avons vu dans la section précédente que les types de formulaire `(Int, Int -> T)` peuvent être utiles pour représenter des collections d’accès aléatoires, donc la fonction <xref:microsoft.quantum.arrays.lookupfunction> fournit un moyen convienent de construire de tels types à partir de types de tableau.</span><span class="sxs-lookup"><span data-stu-id="315cb-108">Similarly, we saw in the previous section that types of the form `(Int, Int -> T)` can be useful for representing random access collections, so the <xref:microsoft.quantum.arrays.lookupfunction> function provides a convienent way of constructing such types from array types.</span></span>

### <a name="pairs"></a><span data-ttu-id="315cb-109">Correspondre</span><span class="sxs-lookup"><span data-stu-id="315cb-109">Pairs</span></span> ###

<span data-ttu-id="315cb-110">Canon prend en charge la notation de style fonctionnel pour les paires, en complément de l’accès aux tuples par déconstruction :</span><span class="sxs-lookup"><span data-stu-id="315cb-110">The canon supports functional-style notation for pairs, complementing accessing tuples by deconstruction:</span></span>

```qsharp
let pair = (PauliZ, register); // type (Pauli, Qubit[])
ApplyToEach(H, Snd(pair)); // No need to deconstruct to access the register.
```

### <a name="arrays"></a><span data-ttu-id="315cb-111">Tableaux</span><span class="sxs-lookup"><span data-stu-id="315cb-111">Arrays</span></span> ###

<span data-ttu-id="315cb-112">Canon fournit plusieurs fonctions pour manipuler des tableaux.</span><span class="sxs-lookup"><span data-stu-id="315cb-112">The canon provides several functions for manipulating arrays.</span></span>
<span data-ttu-id="315cb-113">Ces fonctions sont paramétrées par type et peuvent donc être utilisées avec les tableaux de n’importe quel type Q #.</span><span class="sxs-lookup"><span data-stu-id="315cb-113">These functions are type-parameterized, and thus can be used with arrays of any Q# type.</span></span>
<span data-ttu-id="315cb-114">Par exemple, la fonction <xref:microsoft.quantum.arrays.reversed> retourne un nouveau tableau dont les éléments sont dans l’ordre inverse de son entrée.</span><span class="sxs-lookup"><span data-stu-id="315cb-114">For instance, the <xref:microsoft.quantum.arrays.reversed> function returns a new array whose elements are in reverse order from its input.</span></span>
<span data-ttu-id="315cb-115">Cela peut être utilisé pour modifier la façon dont un registre Quantum est représenté lors de l’appel d’opérations :</span><span class="sxs-lookup"><span data-stu-id="315cb-115">This can be used to change how a quantum register is represented when calling operations:</span></span>

```qsharp
let leRegister = LittleEndian(register);
// QFT expects a BigEndian, so we can reverse before calling.
QFT(BigEndian(Reversed(leRegister!)));
// This is how the LittleEndianAsBigEndian function is implemented:
QFT(LittleEndianAsBigEndian(leRegister));
```

<span data-ttu-id="315cb-116">De même, la fonction <xref:microsoft.quantum.arrays.subarray> peut être utilisée pour réorganiser ou prendre des sous-ensembles des éléments d’un tableau :</span><span class="sxs-lookup"><span data-stu-id="315cb-116">Similarly, the <xref:microsoft.quantum.arrays.subarray> function can be used to reorder or take subsets of the elements of an array:</span></span>

```qsharp
// Applies H to qubits 2 and 5.
ApplyToEach(H, Subarray([2, 5], register));
```

<span data-ttu-id="315cb-117">Lorsqu’il est associé à un contrôle de Flow, les fonctions de manipulation de tableau comme <xref:microsoft.quantum.arrays.zip> peuvent offrir un moyen puissant d’exprimer des programmes Quantum :</span><span class="sxs-lookup"><span data-stu-id="315cb-117">When combined with flow control, array manipulation functions such as <xref:microsoft.quantum.arrays.zip> can provide a powerful way to express quantum programs:</span></span>

```qsharp
// Applies X₃ Y₁ Z₇ to a register of any size.
ApplyToEach(
    ApplyPauli(_, register),
    Map(
        EmbedPauli(_, _, Length(register)),
        Zip([PauliX, PauliY, PauliZ], [3, 1, 7])
    )
);
```

## <a name="oracles"></a><span data-ttu-id="315cb-118">Oracle</span><span class="sxs-lookup"><span data-stu-id="315cb-118">Oracles</span></span> ##

<span data-ttu-id="315cb-119">Dans la documentation sur l' [estimation de phase](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) et l' [amplification d’amplitude](https://en.wikipedia.org/wiki/Amplitude_amplification) , le concept d’Oracle s’affiche fréquemment.</span><span class="sxs-lookup"><span data-stu-id="315cb-119">In the [phase estimation](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm) and [amplitude amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) literature the concept of an oracle appears frequently.</span></span>
<span data-ttu-id="315cb-120">Ici, le terme Oracle fait référence à une sous-routine Quantum Blackbox qui agit sur un ensemble de qubits et renvoie la réponse en tant que phase.</span><span class="sxs-lookup"><span data-stu-id="315cb-120">Here the term oracle refers to a blackbox quantum subroutine that acts upon a set of qubits and returns the answer as a phase.</span></span>
<span data-ttu-id="315cb-121">Cette sous-routine peut souvent être considérée comme une entrée d’un algorithme Quantum qui accepte Oracle, en plus d’autres paramètres, et applique une série d’opérations de Quantum et traite un appel à cette sous-routine Quantum comme s’il s’agissait d’une porte fondamentale.</span><span class="sxs-lookup"><span data-stu-id="315cb-121">This subroutine often can be thought of as an input to a quantum algorithm that accepts the oracle, in addition to some other parameters, and applies a series of quantum operations and treating a call to this quantum subroutine as if it were a fundamental gate.</span></span>
<span data-ttu-id="315cb-122">Évidemment, pour implémenter réellement le plus grand algorithme, une décomposition concrète d’Oracle en portes fondamentales doit être fournie, mais une telle décomposition n’est pas nécessaire pour comprendre l’algorithme qui appelle Oracle.</span><span class="sxs-lookup"><span data-stu-id="315cb-122">Obviously, in order to actually implement the larger algorithm a concrete decomposition of the oracle into fundamental gates must be provided but such a decomposition is not needed in order to understand the algorithm that calls the oracle.</span></span>
<span data-ttu-id="315cb-123">Dans Q #, cette abstraction est représentée à l’aide de ces opérations qui sont des valeurs de première classe, de telle sorte que les opérations peuvent être passées aux implémentations des algorithmes de Quantum en utilisant une boîte noire.</span><span class="sxs-lookup"><span data-stu-id="315cb-123">In Q#, this abstraction is represented by using that operations are first-class values, such that operations can be passed to implementations of quantum algorithms in a black-box manner.</span></span>
<span data-ttu-id="315cb-124">En outre, les types définis par l’utilisateur sont utilisés pour étiqueter les différentes représentations Oracle d’une manière sécurisée, ce qui rend difficile le blocage accidentel de différents genres d’opérations de boîte noire.</span><span class="sxs-lookup"><span data-stu-id="315cb-124">Moreover, user-defined types are used to label the different oracle representations in a type-safe way, making it difficult to accidently conflate different kinds of black box operations.</span></span>

<span data-ttu-id="315cb-125">Ces Oracle apparaissent dans plusieurs contextes différents, y compris des exemples célèbres, tels que les algorithmes [de recherche et de simulation de quantum de Grover](https://en.wikipedia.org/wiki/Grover%27s_algorithm) .</span><span class="sxs-lookup"><span data-stu-id="315cb-125">Such oracles appear in a number of different contexts, including famous examples such as [Grover's search](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and quantum simulation algorithms.</span></span>
<span data-ttu-id="315cb-126">Ici, nous nous concentrons sur les Oracle requis pour deux applications seulement : amplification d’amplitude et estimation de phase.</span><span class="sxs-lookup"><span data-stu-id="315cb-126">Here we focus on the oracles needed for just two applications: amplitude amplification and phase estimation.</span></span>
<span data-ttu-id="315cb-127">Nous allons tout d’abord aborder les Oracle amplification d’amplitude avant de procéder à l’estimation de phase.</span><span class="sxs-lookup"><span data-stu-id="315cb-127">We will first discuss amplitude amplification oracles before proceding to phase estimation.</span></span>

### <a name="amplitude-amplification-oracles"></a><span data-ttu-id="315cb-128">Amplification d’amplitude Oracle</span><span class="sxs-lookup"><span data-stu-id="315cb-128">Amplitude Amplification Oracles</span></span> ###

<span data-ttu-id="315cb-129">L’algorithme d’amplification d’amplitude vise à effectuer une rotation entre un état initial et un état final en appliquant une séquence de réflexions de l’État.</span><span class="sxs-lookup"><span data-stu-id="315cb-129">The amplitude amplification algorithm aims to perform a rotation between an initial state and a final state by applying a sequence of reflections of the state.</span></span>
<span data-ttu-id="315cb-130">Pour que l’algorithme fonctionne, il a besoin d’une spécification de ces deux États.</span><span class="sxs-lookup"><span data-stu-id="315cb-130">In order for the algorithm to function, it needs a specification of both of these states.</span></span>
<span data-ttu-id="315cb-131">Ces spécifications sont fournies par deux Oracle.</span><span class="sxs-lookup"><span data-stu-id="315cb-131">These specifications are given by two oracles.</span></span>
<span data-ttu-id="315cb-132">Ces Oracle fonctionnent en séparant les entrées en deux espaces, un sous-espace « cible » et un sous-espace « initial ».</span><span class="sxs-lookup"><span data-stu-id="315cb-132">These oracles work by breaking the inputs into two spaces, a "target" subspace and an "initial" subspace.</span></span>
<span data-ttu-id="315cb-133">Les Oracle identifient de tels sous-espaces, de la même façon que les opérateurs Pauli identifient deux espaces, en appliquant une phase $ \pm $1 à ces espaces.</span><span class="sxs-lookup"><span data-stu-id="315cb-133">The oracles identify such subspaces, similar to how Pauli operators identify two spaces, by applying a $\pm 1$ phase to these spaces.</span></span>
<span data-ttu-id="315cb-134">La principale différence réside dans le fait que ces espaces n’ont pas besoin d’être des demi-espaces dans cette application.</span><span class="sxs-lookup"><span data-stu-id="315cb-134">The main difference is that these spaces need not be half-spaces in this application.</span></span>
<span data-ttu-id="315cb-135">Notez également que ces deux sous-espaces ne sont généralement pas mutuellement exclusifs : il y aura des vecteurs qui sont membres des deux espaces.</span><span class="sxs-lookup"><span data-stu-id="315cb-135">Also note that these two subspaces are not usually mutually exclusive: there will be vectors that are members of both spaces.</span></span>
<span data-ttu-id="315cb-136">Si ce n’est pas le cas, alors l’amplification d’amplitude n’aurait aucun effet. par conséquent, nous avons besoin du sous-espace initial pour avoir un chevauchement différent de zéro avec le sous-espace cible.</span><span class="sxs-lookup"><span data-stu-id="315cb-136">If this were not true then amplitude amplification would have no effect so we need the initial subspace to have non-zero overlap with the target subspace.</span></span>

<span data-ttu-id="315cb-137">Nous désignerons la première Oracle dont nous avons besoin pour l’amplification de l’amplitude afin d’être $P\_$0, définie pour avoir l’action suivante.</span><span class="sxs-lookup"><span data-stu-id="315cb-137">We will denote the first oracle that we need for amplitude amplification to be $P\_0$, defined to have the following action.</span></span>  <span data-ttu-id="315cb-138">Pour tous les États $ \ket{x} $ dans le sous-espace « initial » $P\_0 \ket{x} =-\ket{x} $ et pour tous les États $ \ket{y} $ qui ne sont pas dans ce sous-espace, nous avons $P\_0 \ket{y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="315cb-138">For all states $\ket{x}$ in the "initial" subspace $P\_0 \ket{x} = -\ket{x}$ and for all states $\ket{y}$ that are not in this subspace we have $P\_0 \ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="315cb-139">L’Oracle qui marque le sous-espace cible, $P _ 1 $, prend exactement la même forme.</span><span class="sxs-lookup"><span data-stu-id="315cb-139">The oracle that marks the target subspace, $P_1$, takes exactly the same form.</span></span>
<span data-ttu-id="315cb-140">Pour tous les États $ \ket{x} $ dans le sous-espace cible (c’est-à-dire, pour tous les États que vous souhaitez que l’algorithme génère), $P _ 1 \ Ket {x} =-\ket{x} $.</span><span class="sxs-lookup"><span data-stu-id="315cb-140">For all states $\ket{x}$ in the target subspace (i.e., for all states that you'd like the algorithm to output), $P_1\ket{x} = -\ket{x}$.</span></span>
<span data-ttu-id="315cb-141">De même, pour tous les États $ \ket{y} $ qui ne se trouvent pas dans le sous-espace cible $P _ 1 \ Ket {y} = \ket{y} $.</span><span class="sxs-lookup"><span data-stu-id="315cb-141">Similarly, for all states $\ket{y}$ that are not in the target subspace $P_1\ket{y} = \ket{y}$.</span></span>
<span data-ttu-id="315cb-142">Ces deux réflexions sont ensuite combinées pour former un opérateur qui exerce une seule étape d’amplification de l’amplitude, $Q =-P_0 P_1 $, où le signe moins est uniquement important à prendre en compte dans les applications contrôlées.</span><span class="sxs-lookup"><span data-stu-id="315cb-142">These two reflections are then combined to form an operator that enacts a single step of amplitude amplification, $Q = -P_0 P_1$, where the overall minus sign is only important to consider in controlled applications.</span></span>
<span data-ttu-id="315cb-143">L’amplification d’amplitude se poursuit ensuite en prenant un état initial, $ \ket{\Psi} $ qui se trouve dans le sous-espace initial, puis exécute $ \ket{\Psi} \mapsto Q ^ m \ket{\Psi} $.</span><span class="sxs-lookup"><span data-stu-id="315cb-143">Amplitude amplification then proceeds by taking an initial state, $\ket{\psi}$ that is in the initial subspace and then performs $\ket{\psi} \mapsto Q^m \ket{\psi}$.</span></span>
<span data-ttu-id="315cb-144">Le fait d’effectuer une telle itération garantit que si l’un d’eux commence par un état initial qui a le chevauchement $ \sin ^ 2 (\Theta) $ avec l’espace marqué, après $m $ iterations, ce chevauchement devient $ \sin ^ 2 ([2m + 1] \Theta) $.</span><span class="sxs-lookup"><span data-stu-id="315cb-144">Performing such an iteration guarantees that if one starts with an initial state that has overlap $\sin^2(\theta)$ with the marked space then after $m$ iterations this overlap becomes $\sin^2([2m + 1] \theta)$.</span></span>
<span data-ttu-id="315cb-145">Par conséquent, nous souhaitons généralement choisir $m $ comme un paramètre gratuit de sorte que $ [2m + 1] \Theta = \ pi/2 $; Toutefois, ces choix rigides ne sont pas aussi importants pour certaines formes d’amplification d’amplitude, telles que l’amplification d’amplitude à virgule fixe.</span><span class="sxs-lookup"><span data-stu-id="315cb-145">We therefore typically wish to choose $m$ to be a free parameter such that $[2m+1]\theta = \pi/2$; however, such rigid choices are not as important for some forms of amplitude amplification such as fixed point amplitude amplification.</span></span>
<span data-ttu-id="315cb-146">Ce processus nous permet de préparer un État dans le sous-espace marqué à l’aide de augmentera moins de requêtes à la fonction de marquage et de la fonction de préparation de l’État qu’il ne serait possible sur un appareil strictement classique.</span><span class="sxs-lookup"><span data-stu-id="315cb-146">This process allows us to prepare a state in the marked subspace using quadratically fewer queries to the marking function and the state preparation function than would be possible on a strictly classical device.</span></span>
<span data-ttu-id="315cb-147">C’est pourquoi l’amplification de l’amplitude est un bloc de construction significatif pour de nombreuses applications de quantum computing.</span><span class="sxs-lookup"><span data-stu-id="315cb-147">This is why amplitude amplification is a significant building block for many applications of quantum computing.</span></span>

<span data-ttu-id="315cb-148">Pour comprendre comment utiliser l’algorithme, il est utile de fournir un exemple qui donne une construction d’Oracle.</span><span class="sxs-lookup"><span data-stu-id="315cb-148">In order to understand how to use the algorithm, it is useful to provide an example that gives a construction of the oracles.</span></span>  <span data-ttu-id="315cb-149">Envisagez d’exécuter l’algorithme de Grover pour les recherches de base de données dans ce paramètre.</span><span class="sxs-lookup"><span data-stu-id="315cb-149">Consider performing Grover's algorithm for database searches in this setting.</span></span>
<span data-ttu-id="315cb-150">Dans la recherche de Grover, l’objectif est de transformer l’État $ \ket{+} ^ {\otimes n} = H ^ {\otimes n} \ket{0}$ dans l’un des États marqués (potentiellement).</span><span class="sxs-lookup"><span data-stu-id="315cb-150">In Grover's search the goal is to transform the state $\ket{+}^{\otimes n} = H^{\otimes n} \ket{0}$ into one of (potentially) many marked states.</span></span>
<span data-ttu-id="315cb-151">Pour simplifier davantage, nous allons simplement examiner le cas où le seul État marqué est $ \ket{0}$.</span><span class="sxs-lookup"><span data-stu-id="315cb-151">To further simplify, let's just look at the case where the only marked state is $\ket{0}$.</span></span>
<span data-ttu-id="315cb-152">Nous avons ensuite conçu deux oracles : un qui marque uniquement l’état initial $ \ket{+} ^ {\otimes n} $ avec un signe moins et un autre qui marque l’État marqué $ \ket{0}$ avec un signe moins.</span><span class="sxs-lookup"><span data-stu-id="315cb-152">Then we have design two oracles: one that only marks the initial state $\ket{+}^{\otimes n}$ with a minus sign and another that marks the marked state $\ket{0}$ with a minus sign.</span></span>
<span data-ttu-id="315cb-153">La dernière porte peut être implémentée à l’aide de l’opération de traitement suivante, à l’aide des opérations de contrôle de workflow dans Canon :</span><span class="sxs-lookup"><span data-stu-id="315cb-153">The latter gate can be implemented using the following process operation, by using the control flow operations in the canon:</span></span>

```qsharp
operation ReflectAboutAllZeros(register : Qubit[]) : Unit 
is Adj + Ctl {

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);

    // Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.
    // This gate will lead to a sign flip if and only if every qubit is
    // $1$, which happens only if each of the qubits were $0$ before step 1.
    Controlled Z(Most(register), Tail(register));

    // Apply $X$ gates to every qubit.
    ApplyToEach(X, register);
}
```

<span data-ttu-id="315cb-154">Cet Oracle est ensuite un cas particulier de l’opération <xref:microsoft.quantum.canon.rall1>, qui permet une rotation par une phase arbitraire au lieu du cas de réflexion $ \Phi = \pi $.</span><span class="sxs-lookup"><span data-stu-id="315cb-154">This oracle is then a special case of the <xref:microsoft.quantum.canon.rall1> operation, which allows for rotating by an arbitrary phase instead of the reflection case $\phi = \pi$.</span></span>
<span data-ttu-id="315cb-155">Dans ce cas, `RAll1` est semblable à l’opération <xref:microsoft.quantum.intrinsic.r1> préambule destiné à, dans le fait qu’il pivote à propos de $ \ket{11\cdots1} $ au lieu de l’État qubit $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="315cb-155">In this case, `RAll1` is similar to the <xref:microsoft.quantum.intrinsic.r1> prelude operation, in that it rotates about $\ket{11\cdots1}$ instead of the single-qubit state $\ket{1}$.</span></span>

<span data-ttu-id="315cb-156">L’Oracle qui marque le sous-espace initial peut être construit de la même manière.</span><span class="sxs-lookup"><span data-stu-id="315cb-156">The oracle that marks the initial subspace can be constructed similarly.</span></span>
<span data-ttu-id="315cb-157">En pseudo-code :</span><span class="sxs-lookup"><span data-stu-id="315cb-157">In pseudocode:</span></span>

1. <span data-ttu-id="315cb-158">Appliquez $H $ Gates à chaque qubit.</span><span class="sxs-lookup"><span data-stu-id="315cb-158">Apply $H$ gates to every qubit.</span></span>
2. <span data-ttu-id="315cb-159">Appliquez $X $ Gates à chaque qubit.</span><span class="sxs-lookup"><span data-stu-id="315cb-159">Apply $X$ gates to every qubit.</span></span>
3. <span data-ttu-id="315cb-160">Appliquez un $n-$1 contrôlé $Z $-Gate à la $n ^ {\text{th}} $ qubit.</span><span class="sxs-lookup"><span data-stu-id="315cb-160">Apply an $n-1$ controlled $Z$-gate to the $n^{\text{th}}$ qubit.</span></span>
4. <span data-ttu-id="315cb-161">Appliquez $X $ Gates à chaque qubit.</span><span class="sxs-lookup"><span data-stu-id="315cb-161">Apply $X$ gates to every qubit.</span></span>
5. <span data-ttu-id="315cb-162">Appliquez $H $ Gates à chaque qubit.</span><span class="sxs-lookup"><span data-stu-id="315cb-162">Apply $H$ gates to every qubit.</span></span>

<span data-ttu-id="315cb-163">Cette fois-ci, nous vous présenterons également l’utilisation de <xref:microsoft.quantum.canon.applywith> avec l’opération <xref:microsoft.quantum.canon.rall1> décrite ci-dessus :</span><span class="sxs-lookup"><span data-stu-id="315cb-163">This time, we also demonstrate using <xref:microsoft.quantum.canon.applywith> together with the <xref:microsoft.quantum.canon.rall1> operation discussed above:</span></span>

```qsharp
operation ReflectAboutInitial(register : Qubit[]) : Unit
is Adj + Ctl {
    ApplyWithCA(ApplyToEach(H, _), ApplyWith(ApplyToEach(X, _), RAll1(_, PI()), _), register);
}
```

<span data-ttu-id="315cb-164">Nous pouvons ensuite combiner ces deux oracles ensemble pour faire pivoter les deux États et transformer de manière déterministe $ \ket{+} ^ {\otimes n} $ en $ \ket{0}$ à l’aide d’un certain nombre de couches de portes Hadarmard qui est proportionnel à $ \sqrt{2 ^ n} $ (IE $m \propto \sqrt{2 ^ n} $) par rapport aux couches de 1 à 2 ^ n $ qui seraient nécessaires pour préparer de manière non déterministe l’État $ \ket{0}$ en préparant et mesurant l’état initial jusqu’à ce que le résultat $0 $ soit respecté.</span><span class="sxs-lookup"><span data-stu-id="315cb-164">We can then combine these two oracles together to rotate between the two states and deterministically transform $\ket{+}^{\otimes n}$ to $\ket{0}$ using a number of layers of Hadamard gates that is proportional to $\sqrt{2^n}$ (ie $m\propto \sqrt{2^n}$) versus the roughly $2^n$ layers that would be needed to non-deterministically prepare the $\ket{0}$ state by preparing and measuring the initial state until the outcome $0$ is observed.</span></span>

### <a name="phase-estimation-oracles"></a><span data-ttu-id="315cb-165">Estimation de phase Oracle</span><span class="sxs-lookup"><span data-stu-id="315cb-165">Phase Estimation Oracles</span></span> ###

<span data-ttu-id="315cb-166">Pour l’estimation de phase, les Oracle sont un peu plus naturels.</span><span class="sxs-lookup"><span data-stu-id="315cb-166">For phase estimation the oracles are somewhat more natural.</span></span>
<span data-ttu-id="315cb-167">L’objectif de la phase d’estimation de la phase est de concevoir une sous-routine capable d’effectuer un échantillonnage à partir du valeurs propres d’une matrice d’unités.</span><span class="sxs-lookup"><span data-stu-id="315cb-167">The aim in phase estimation is to design a subroutine that is capable of sampling from the eigenvalues of a unitary matrix.</span></span>
<span data-ttu-id="315cb-168">Cette méthode est indispensable dans la simulation quantique, car pour de nombreux problèmes physiques dans la chimie et la science de la matériel, ces valeurs propres offrent les énergies de l’état de masse des systèmes quantiques qui nous fournissent des informations précieuses sur les diagrammes de phase de matériaux et dynamique de réaction pour les molécules.</span><span class="sxs-lookup"><span data-stu-id="315cb-168">This method is indispensible in quantum simulation because for many physical problems in chemistry and material science these eigenvalues give the ground-state energies of quantum systems which provides us valuable information about the phase diagrams of materials and reaction dynamics for molecules.</span></span>
<span data-ttu-id="315cb-169">Chaque version d’estimation de phase a besoin d’une unité d’entrée.</span><span class="sxs-lookup"><span data-stu-id="315cb-169">Every flavor of phase estimation needs an input unitary.</span></span>
<span data-ttu-id="315cb-170">Cette unité est habituellement décrite par l’un des deux types d’Oracle.</span><span class="sxs-lookup"><span data-stu-id="315cb-170">This unitary is customarily described by one of two types of oracles.</span></span>

> [!TIP]
> <span data-ttu-id="315cb-171">Les deux types Oracle décrits ci-dessous sont traités dans les exemples.</span><span class="sxs-lookup"><span data-stu-id="315cb-171">Both of the oracle types described below are covered in the samples.</span></span>
> <span data-ttu-id="315cb-172">Pour en savoir plus sur les requêtes Oracle continues, consultez l' [exemple **PhaseEstimation** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/PhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="315cb-172">To learn more about continuous query oracles, please see the [**PhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/PhaseEstimation).</span></span>
> <span data-ttu-id="315cb-173">Pour en savoir plus sur les requêtes discrètes Oracle, consultez l' [exemple **IsingPhaseEstimation** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="315cb-173">To learn more about discrete query oracles, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>

<span data-ttu-id="315cb-174">Le premier type d’Oracle, que nous appelons une requête discrète Oracle et qui représente le type défini par l’utilisateur <xref:microsoft.quantum.oracles.discreteoracle>, implique simplement une matrice d’unités.</span><span class="sxs-lookup"><span data-stu-id="315cb-174">The first type of oracle, which we call a discrete query oracle and represent with the user-defined type <xref:microsoft.quantum.oracles.discreteoracle>, simply involves a unitary matrix.</span></span>
<span data-ttu-id="315cb-175">Si $U $ est l’unité de valeurs propres que nous souhaitons estimer, alors Oracle for $U $ est simplement une solution de secours pour une sous-routine qui implémente $U $.</span><span class="sxs-lookup"><span data-stu-id="315cb-175">If $U$ is the unitary whose eigenvalues we wish to estimate then the oracle for $U$ is simply a stand-in for a subroutine that implements $U$.</span></span>
<span data-ttu-id="315cb-176">Par exemple, il peut s’agir $U $ comme Oracle $Q $ défini ci-dessus pour l’estimation de l’amplitude.</span><span class="sxs-lookup"><span data-stu-id="315cb-176">For example, one could take $U$ to be the oracle $Q$ defined above for amplitude estimation.</span></span>
<span data-ttu-id="315cb-177">Le valeurs propres de cette matrice peut être utilisé pour estimer le chevauchement entre les États initial et cible, $ \sin ^ 2 (\Theta) $, en utilisant augmentera moins d’échantillons que l’un d’eux n’en aurait besoin autrement.</span><span class="sxs-lookup"><span data-stu-id="315cb-177">The eigenvalues of this matrix can be used to estimate the overlap between the initial and target states, $\sin^2(\theta)$, using quadratically fewer samples than one would need otherwise.</span></span>
<span data-ttu-id="315cb-178">Cela a pour avantage l’application d’une estimation de phase utilisant Grover Oracle $Q $ comme entrée du moniker de l’estimation de l’amplitude.</span><span class="sxs-lookup"><span data-stu-id="315cb-178">This earns the application of phase estimation using the Grover oracle $Q$ as input the moniker of amplitude estimation.</span></span>
<span data-ttu-id="315cb-179">Une autre application courante, largement utilisée dans la métrologie quantique, implique l’estimation d’un petit angle de rotation.</span><span class="sxs-lookup"><span data-stu-id="315cb-179">Another common application, widely used in quantum metrology, involves estimating a small rotation angle.</span></span>
<span data-ttu-id="315cb-180">En d’autres termes, nous souhaitons estimer $ \Theta $ pour une porte de rotation inconnue au format $R _Z (\Theta) $.</span><span class="sxs-lookup"><span data-stu-id="315cb-180">In other words, we wish to estimate $\theta$ for an unknown rotation gate of the form $R_z(\theta)$.</span></span>
<span data-ttu-id="315cb-181">Dans ce cas, la sous-routine avec laquelle nous interagissons afin d’obtenir cette valeur fixe de $ \Theta $ pour la porte est $ $ \begin{align} U & = R_z (\Theta) \\\\ & = \begin{bmatrix} e ^ {-i \Theta/2} & 0 \\\\ 0 & e ^ {i \ thêta/2} \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="315cb-181">In such cases, the subroutine that we would interact with in order to learn this fixed value of $\theta$ for the gate is $$ \begin{align} U & = R_z(\theta) \\\\ & = \begin{bmatrix} e^{-i \theta / 2} & 0 \\\\ 0 & e^{i\theta/2} \end{bmatrix}.</span></span>
<span data-ttu-id="315cb-182">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="315cb-182">\end{align} $$</span></span>

<span data-ttu-id="315cb-183">Le deuxième type d’Oracle utilisé dans l’estimation de la phase est la requête continue Oracle, représentée par le type de <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="315cb-183">The second type of oracle used in phase estimation is the continuous query oracle, represented by the <xref:microsoft.quantum.oracles.continuousoracle> type.</span></span>
<span data-ttu-id="315cb-184">Une requête continue Oracle for phase estimation prend la forme $U (t) $ où $t $ est un nombre réel connu.</span><span class="sxs-lookup"><span data-stu-id="315cb-184">A continuous query oracle for phase estimation takes the form $U(t)$ where $t$ is a classically known real number.</span></span>
<span data-ttu-id="315cb-185">Si nous laissons $U $ être une unité fixe, la requête continue Oracle prend la forme $U (t) = U ^ t $.</span><span class="sxs-lookup"><span data-stu-id="315cb-185">If we let $U$ be a fixed unitary then the continuous query oracle takes the form $U(t) = U^t$.</span></span>
<span data-ttu-id="315cb-186">Cela nous permet d’interroger des matrices telles que $ \sqrt{U} $, qui n’ont pas pu être implémentées directement dans le modèle de requête discret.</span><span class="sxs-lookup"><span data-stu-id="315cb-186">This allows us to query matrices such as $\sqrt{U}$, which could not be implemented directly in the discrete query model.</span></span>

<span data-ttu-id="315cb-187">Ce type d’Oracle est utile lorsque vous n’êtes pas en train de sonder une unité particulière, mais que vous souhaitez plutôt apprendre les propriétés du générateur de l’unité.</span><span class="sxs-lookup"><span data-stu-id="315cb-187">This type of oracle is valuable when you're not probing a particular unitary, but rather wish to learn the properties of the generator of the unitary.</span></span>
<span data-ttu-id="315cb-188">Par exemple, dans la simulation de Quantum dynamique, l’objectif est de concevoir des circuits quantiques qui se rapprochent $U (t) = e ^ {-i H t} $ pour une matrice Hermitian $H $ et l’heure d’évolution $t $.</span><span class="sxs-lookup"><span data-stu-id="315cb-188">For example, in dynamical quantum simulation the goal is to devise quantum circuits that closely approximate $U(t)=e^{-i H t}$ for a Hermitian matrix $H$ and evolution time $t$.</span></span>
<span data-ttu-id="315cb-189">Le valeurs propres de $U (t) $ est directement lié au valeurs propres de $H $.</span><span class="sxs-lookup"><span data-stu-id="315cb-189">The eigenvalues of $U(t)$ are directly related to the eigenvalues of $H$.</span></span>
<span data-ttu-id="315cb-190">Pour voir cela, considérez un extraction de $H $ : $H \ket{E} = E\ket {E} $, puis il est facile de voir la définition de la série Power de la matrice exponentielle qui $U (t) \ket{E} = e ^ {i\phi} \ Ket {E} = e ^ {-iEt} \ket{E} $.</span><span class="sxs-lookup"><span data-stu-id="315cb-190">To see this, consider an eigenvector of $H$: $H \ket{E} = E\ket{E}$ then it is easy to see from the power-series definition of the matrix exponential that $U(t) \ket{E} = e^{i\phi}\ket{E}= e^{-iEt}\ket{E}$.</span></span>
<span data-ttu-id="315cb-191">Par conséquent, l’estimation de la eigenphase de $U (t) $ donne au eigenvalue $E $ en supposant que le extraction $ \ket{E} $ est entré dans l’algorithme d’estimation de la phase.</span><span class="sxs-lookup"><span data-stu-id="315cb-191">Thus estimating the eigenphase of $U(t)$ gives the eigenvalue $E$ assuming the eigenvector $\ket{E}$ is input into the phase estimation algorithm.</span></span>
<span data-ttu-id="315cb-192">Toutefois, dans ce cas, la valeur $t $ peut être choisie à la discrétion de l’utilisateur, car pour toute valeur suffisamment faible de $t $ eigenvalue $E $ peut être inversée de manière unique via $E =-\ Phi/t $.</span><span class="sxs-lookup"><span data-stu-id="315cb-192">However, in this case the value $t$ can be chosen at the user's discretion since for any sufficiently small value of $t$ the eigenvalue $E$ can be uniquely inverted through $E=-\phi/t$.</span></span>
<span data-ttu-id="315cb-193">Étant donné que les méthodes de simulation quantique offrent la possibilité d’effectuer une évolution fractionnaire, les algorithmes d’estimation de phase allocations sont une liberté supplémentaire lors de l’interrogation de l’unité, en particulier lorsque le modèle de requête discret autorise uniquement les unités de la forme $U ^ j $ à appliquer pour les entiers $j $ la requête continue Oracle nous permet d’obtenir des unités approximatives de la forme $U ^ t $ pour toute valeur réelle $t $.</span><span class="sxs-lookup"><span data-stu-id="315cb-193">Since quantum simulation methods provide the ability to perform a fractional evolution, this grants phase estimation algorithms an additional freedom when querying the unitary, specifically while the discrete query model allows only unitaries of the form $U^j$ to applied for integer $j$ the continuous query oracle allows us to approximate unitaries of the form $U^t$ for any real valued $t$.</span></span>
<span data-ttu-id="315cb-194">Il est important de s’assurer que chaque dernière onces d’efficacité est un algorithme d’estimation hors phase, car cela nous permet de choisir précisément l’expérience qui fournirait le plus d’informations sur $E $; tandis que les méthodes basées sur des requêtes discrètes doivent faire l’intérêt d’une compromission en choisissant le meilleur nombre entier de requêtes dans l’algorithme.</span><span class="sxs-lookup"><span data-stu-id="315cb-194">This is important to squeeze every last ounce of efficiency out of phase estimation algorithms because it allows us to choose precisely the experiment that would provide the most information about $E$; whereas methods based on discrete queries must make do with compromising by choosing the best integer number of queries in the algorithm.</span></span>

<span data-ttu-id="315cb-195">En guise d’exemple concret, considérez le problème d’estimation non de l’angle de rotation d’une porte, mais la fréquence procession d’un système Quantum tournant.</span><span class="sxs-lookup"><span data-stu-id="315cb-195">As a concrete example of this, consider the problem of estimating not the rotation angle of a gate but the procession frequency of a rotating quantum system.</span></span>
<span data-ttu-id="315cb-196">L’unité qui décrit cette dynamique quantique est $U (t) = R_z (2 \ Omega t) $ pour l’heure d’évolution $t $ et la fréquence inconnue $ \omega $.</span><span class="sxs-lookup"><span data-stu-id="315cb-196">The unitary that describes such quantum dynamics is $U(t)=R_z(2\omega t)$ for evolution time $t$ and unknown frequency $\omega$.</span></span>
<span data-ttu-id="315cb-197">Dans ce contexte, nous pouvons simuler $U (t) $ pour n’importe quel $t $ à l’aide d’une seule $R _Z $ Gate et, par conséquent, il n’est pas nécessaire de nous limiter à des requêtes discrètes à l’unité.</span><span class="sxs-lookup"><span data-stu-id="315cb-197">In this context, we can simulate $U(t)$ for any $t$ using a single $R_z$ gate and as such do not need to restrict ourselves to only discrete queries to the unitary.</span></span>
<span data-ttu-id="315cb-198">Un tel modèle continu a également la propriété dont les fréquences supérieures à $2 \ pi $ peuvent être apprises dans les processus d’estimation de phase qui utilisent des requêtes continues, car les informations de phase qui seraient autrement masquées par les coupes de la fonction logarithmique peuvent être dévoilées à partir des résultats des expérimentations effectuées sur des valeurs non proportionnées de $t $.</span><span class="sxs-lookup"><span data-stu-id="315cb-198">Such a continuous model also has the property that frequencies greater than $2\pi$ can be learned from phase estimation processes that use continuous queries because phase information that would otherwise be masked by the branch-cuts of the logarithm function can be revealed from the results of experiments performed on non-commensurate values of $t$.</span></span>
<span data-ttu-id="315cb-199">Ainsi, pour les problèmes tels que les modèles de requête continues pour l’estimation de phase Oracle, ils sont non seulement appropriés, mais ils sont également préférables au modèle de requête discret.</span><span class="sxs-lookup"><span data-stu-id="315cb-199">Thus for problems such as this continuous query models for the phase estimation oracle are not only appropriate but are also preferable to the discrete query model.</span></span>
<span data-ttu-id="315cb-200">Pour cette raison, Q # a des fonctionnalités pour les deux formes de requêtes et laisse l’utilisateur décider d’un algorithme d’estimation de la phase en fonction de ses besoins et du type d’Oracle disponible.</span><span class="sxs-lookup"><span data-stu-id="315cb-200">For this reason Q# has functionality for both forms of queries and leave it to the user to decide upon a phase estimation algorithm to fit their needs and the type of oracle that is available.</span></span>

## <a name="dynamical-generator-modeling"></a><span data-ttu-id="315cb-201">Modélisation de générateurs dynamiques</span><span class="sxs-lookup"><span data-stu-id="315cb-201">Dynamical Generator Modeling</span></span> ##

<span data-ttu-id="315cb-202">Les générateurs de temps-évolution décrivent comment les États évoluent dans le temps.</span><span class="sxs-lookup"><span data-stu-id="315cb-202">Generators of time-evolution describe how states evolve through time.</span></span> <span data-ttu-id="315cb-203">Par exemple, la dynamique d’un État Quantum $ \ket{\Psi} $ est régie par l’équation Schrödinger $ $ \begin{align} i\frac {d \ket{\Psi (t)}} {d t} & = H \ket{\Psi (t)}, \end{align} $ $ avec une matrice Hermitian $H $, appelée « Hamilton », comme générateur de films.</span><span class="sxs-lookup"><span data-stu-id="315cb-203">For instance, the dynamics of a quantum state $\ket{\psi}$ is governed by the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ with a Hermitian matrix $H$, known as the Hamiltonian, as the generator of motion.</span></span> <span data-ttu-id="315cb-204">Étant donné un état initial $ \ket{\Psi (0)} $ à temps $t = $0, la solution formelle à cette équation $t $ peut être, en principe, écrite $ $ \begin{align} \ket{\Psi (t)} = U (t) \ket{\Psi (0)}, \end{align} $ $ où la matrice exponentielle $U (t) = e ^ {-i H t} $ est appelée opérateur d’évolution temporelle.</span><span class="sxs-lookup"><span data-stu-id="315cb-204">Given an initial state $\ket{\psi(0)}$ at time $t=0$, the formal solution to this equation at time $t$ may be, in principle, written $$ \begin{align} \ket{\psi(t)} = U(t)\ket{\psi(0)}, \end{align} $$ where the matrix exponential $U(t)=e^{-i H t}$ is known as the unitary time-evolution operator.</span></span> <span data-ttu-id="315cb-205">Bien que nous nous concentrons sur les générateurs de ce formulaire dans ce qui suit, nous insistons sur le fait que le concept s’applique plus largement, par exemple à la simulation de systèmes quantiques ouverts, ou à des équations différentielles plus abstraites.</span><span class="sxs-lookup"><span data-stu-id="315cb-205">Though we focus on generators of this form in the following, we emphasize that the concept applies more broadly, such as to the simulation of open quantum systems, or to more abstract differential equations.</span></span>

<span data-ttu-id="315cb-206">L’objectif principal de la simulation dynamique est d’implémenter l’opérateur de l’évolution temporelle sur un État Quantum encodé dans qubits d’un ordinateur quantique.</span><span class="sxs-lookup"><span data-stu-id="315cb-206">A primary goal of dynamical simulation is to implement the time-evolution operator on some quantum state encoded in qubits of a quantum computer.</span></span>  <span data-ttu-id="315cb-207">Dans de nombreux cas, la partie Hamilton peut être divisée en une somme de quelques termes $d $ plus simples</span><span class="sxs-lookup"><span data-stu-id="315cb-207">In many cases, the Hamiltonian may be broken into a sum of some $d$ simpler terms</span></span>

<span data-ttu-id="315cb-208">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j, \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="315cb-208">$$ \begin{align} H & = \sum^{d-1}_{j=0} H_j, \end{align} $$</span></span>

<span data-ttu-id="315cb-209">où l’évolution du temps par chaque terme est facile à implémenter sur un ordinateur quantique.</span><span class="sxs-lookup"><span data-stu-id="315cb-209">where time-evolution by each term alone is easy to implement on a quantum computer.</span></span> <span data-ttu-id="315cb-210">Par exemple, si $H _J $ est un Pauli $X _1X_2 $ Operator agissant sur les 1er et 2e éléments du Registre qubit `qubits`, Time-Evolution pour chaque fois $t $ peut être implémenté simplement en appelant l’opération `Exp([PauliX,PauliX], t, qubits[1..2])`, qui a une `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`de signature.</span><span class="sxs-lookup"><span data-stu-id="315cb-210">For instance, if $H_j$ is a Pauli $X_1X_2$ operator acting on the 1st and 2nd elements of the qubit register `qubits`, time-evolution by it for any time $t$ may be implemented simply by calling the operation `Exp([PauliX,PauliX], t, qubits[1..2])`, which has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span> <span data-ttu-id="315cb-211">Comme nous l’avons vu plus loin dans la simulation de la version Hamilton, une solution consiste à évaluer l’évolution du temps en $H $ avec une séquence d’opérations plus simples.</span><span class="sxs-lookup"><span data-stu-id="315cb-211">As discussed later in Hamiltonian Simulation, one solution then is to approximate time-evolution by $H$ with a sequence of simpler operations</span></span>

<span data-ttu-id="315cb-212">$ $ \begin{align} U (t) & = \left (e ^ {-m-m\_0 t/r} e ^ {--1\_1 t/r} \cdots e ^ {-\_{d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \max_j \\| H\_j\\| ^ 2 t ^ 2/r), \end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="315cb-212">$$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j \\|H\_j\\|^2 t^2/r), \end{align} $$</span></span>

<span data-ttu-id="315cb-213">où l’entier $r > $0 contrôle l’erreur d’approximation.</span><span class="sxs-lookup"><span data-stu-id="315cb-213">where the integer $r > 0$ controls the approximation error.</span></span>

<span data-ttu-id="315cb-214">La bibliothèque de modélisation de générateurs dynamiques fournit une infrastructure pour l’encodage systématique des générateurs complexes en termes de générateurs plus simples.</span><span class="sxs-lookup"><span data-stu-id="315cb-214">The dynamical generator modeling library provides a framework for systematically encoding complicated generators in terms of simpler generators.</span></span> <span data-ttu-id="315cb-215">Une telle description peut ensuite être transmise à, par exemple, la bibliothèque de simulation pour implémenter l’évolution du temps par un algorithme de simulation de choix, avec de nombreux détails automatiquement pris en charge.</span><span class="sxs-lookup"><span data-stu-id="315cb-215">Such a description may then be passed to, say, the simulation library to implement time-evolution by a simulation algorithm of choice, with many details automatically taken care of.</span></span>

> [!TIP]
> <span data-ttu-id="315cb-216">La bibliothèque de générateurs dynamiques décrite ci-dessous est traitée dans les exemples.</span><span class="sxs-lookup"><span data-stu-id="315cb-216">The dynamical generator library described below is covered in the samples.</span></span> <span data-ttu-id="315cb-217">Pour obtenir un exemple basé sur le modèle Ising, consultez l' [exemple **IsingGenerators** ](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingGenerators).</span><span class="sxs-lookup"><span data-stu-id="315cb-217">For an example based on the Ising model, please see the [**IsingGenerators** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingGenerators).</span></span>
> <span data-ttu-id="315cb-218">Pour obtenir un exemple basé sur l’hydrogène moléculaire, consultez les exemples [**H2SimulationCmdLine**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) et [**H2SimulationGUI**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationGUI) .</span><span class="sxs-lookup"><span data-stu-id="315cb-218">For an example based on molecular Hydrogen, please see the [**H2SimulationCmdLine**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) and [**H2SimulationGUI**](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationGUI) samples.</span></span>

### <a name="complete-description-of-a-generator"></a><span data-ttu-id="315cb-219">Description complète d’un générateur</span><span class="sxs-lookup"><span data-stu-id="315cb-219">Complete Description of a Generator</span></span> ###

<span data-ttu-id="315cb-220">Au niveau supérieur, une description complète d’un type de type Hamilton est contenue dans le `EvolutionGenerator` type défini par l’utilisateur qui a deux composants :</span><span class="sxs-lookup"><span data-stu-id="315cb-220">At the top level, a complete description of a Hamiltonian is contained in the `EvolutionGenerator` user-defined type which has two components.:</span></span>

```qsharp
newtype EvolutionGenerator = (EvolutionSet, GeneratorSystem);
```

<span data-ttu-id="315cb-221">Le type de `GeneratorSystem` défini par l’utilisateur est une description classique de l’un des.</span><span class="sxs-lookup"><span data-stu-id="315cb-221">The `GeneratorSystem` user-defined type is a classical description of the Hamiltonian.</span></span>

```qsharp
newtype GeneratorSystem = (Int, (Int -> GeneratorIndex));
```

<span data-ttu-id="315cb-222">Le premier élément `Int` du tuple stocke le nombre de termes $d $ dans l’un des deux, et le deuxième élément `(Int -> GeneratorIndex)` est une fonction qui mappe un index d’entiers dans $\{0, 1,..., d-1\}$ à un type défini par l’utilisateur `GeneratorIndex` qui identifie de façon unique chaque terme primitif dans le présentisme.</span><span class="sxs-lookup"><span data-stu-id="315cb-222">The first element `Int` of the tuple stores the number of terms $d$ in the Hamiltonian, and the second element `(Int -> GeneratorIndex)` is a function that maps an integer index in $\{0,1,...,d-1\}$ to a `GeneratorIndex` user-defined type which uniquely identifies each primitive term in the Hamiltonian.</span></span> <span data-ttu-id="315cb-223">Notez qu’en exprimant la collection de termes dans la « Hamilton » en tant que fonction plutôt qu’en tant que tableau `GeneratorIndex[]`, cela permet le calcul à la volée du `GeneratorIndex` qui est particulièrement utile lors de la description de Hamiltonians avec un grand nombre de termes.</span><span class="sxs-lookup"><span data-stu-id="315cb-223">Note that by expressing the collection of terms in the Hamiltonian as a function rather than as an array `GeneratorIndex[]`, this allows for on-the-fly computation of the `GeneratorIndex` which is especially useful when describing Hamiltonians with a large number of terms.</span></span>

<span data-ttu-id="315cb-224">Pour l’essentiel, nous n’avons pas imposé de Convention sur les termes primitifs identifiés par les `GeneratorIndex` sont faciles à simuler.</span><span class="sxs-lookup"><span data-stu-id="315cb-224">Crucially, we do not impose a convention on what primitive terms identified by the `GeneratorIndex` are easy-to-simulate.</span></span> <span data-ttu-id="315cb-225">Par exemple, les termes primitifs peuvent être des opérateurs Pauli comme indiqué ci-dessus, mais ils peuvent également être Fermionic annihilation et des opérateurs de création couramment utilisés dans la simulation de chimie quantique.</span><span class="sxs-lookup"><span data-stu-id="315cb-225">For instance, primitive terms could be Pauli operators as discussed above, but they could also be Fermionic annihilation and creation operators commonly used in quantum chemistry simulation.</span></span> <span data-ttu-id="315cb-226">En soi, un `GeneratorIndex` n’a pas de sens, car il ne décrit pas comment l’évolution temporelle du terme vers laquelle il pointe peut être implémentée en tant que circuit quantique.</span><span class="sxs-lookup"><span data-stu-id="315cb-226">By itself, a `GeneratorIndex` is meaningless as it does not describe how time-evolution by the term it points to may be implemented as a quantum circuit.</span></span>

<span data-ttu-id="315cb-227">Cela est résolu en spécifiant un `EvolutionSet` type défini par l’utilisateur qui mappe tout `GeneratorIndex`, dessiné à partir d’un ensemble canonique, à un opérateur unitaire, le `EvolutionUnitary`, exprimé comme un circuit quantique.</span><span class="sxs-lookup"><span data-stu-id="315cb-227">This is resolved by specifying an `EvolutionSet` user-defined type that maps any `GeneratorIndex`, drawn from some canonical set, to a unitary operator, the `EvolutionUnitary`, expressed as a quantum circuit.</span></span> <span data-ttu-id="315cb-228">L' `EvolutionSet` définit la Convention de la structure d’un `GeneratorIndex` et définit également l’ensemble des `GeneratorIndex`possibles.</span><span class="sxs-lookup"><span data-stu-id="315cb-228">The `EvolutionSet` defines the convention of how a `GeneratorIndex` is structured, and also defines the set of possible `GeneratorIndex`.</span></span>

```qsharp
newtype EvolutionSet = (GeneratorIndex -> EvolutionUnitary);
```

### <a name="pauli-operator-generators"></a><span data-ttu-id="315cb-229">Générateurs d’opérateur Pauli</span><span class="sxs-lookup"><span data-stu-id="315cb-229">Pauli Operator Generators</span></span> ###

<span data-ttu-id="315cb-230">Un exemple concret et utile de générateurs est un Hamiltonians qui est une somme d’opérateurs Pauli, chacun pouvant avoir un coefficient différent.</span><span class="sxs-lookup"><span data-stu-id="315cb-230">A concrete and useful example of generators are Hamiltonians that are a sum of Pauli operators, each possibly with a different coefficient.</span></span>
<span data-ttu-id="315cb-231">$ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} a_j H_j, \end{align} $ $ où chaque $ \hat H_j $ est maintenant dessiné à partir du groupe Pauli.</span><span class="sxs-lookup"><span data-stu-id="315cb-231">$$ \begin{align} H & = \sum^{d-1}_{j=0} a_j H_j, \end{align} $$ where each $\hat H_j$ is now drawn from the Pauli group.</span></span> <span data-ttu-id="315cb-232">Pour ces systèmes, nous fournissons le `PauliEvolutionSet()` de type `EvolutionSet` qui définit une convention pour la façon dont un élément du groupe Pauli et un coefficient peuvent être identifiés par un `GeneratorIndex`, qui a la signature suivante.</span><span class="sxs-lookup"><span data-stu-id="315cb-232">For such systems, we provide the `PauliEvolutionSet()` of type `EvolutionSet` that defines a convention for how an element of the Pauli group and a coefficient may be identified by a `GeneratorIndex`, which has the following signature.</span></span>

```qsharp
newtype GeneratorIndex = ((Int[], Double[]), Int[]);
```

<span data-ttu-id="315cb-233">Dans notre encodage, le premier paramètre `Int[]` spécifie une chaîne Pauli, où $ \hat I\rightarrow $0, $ \hat X\rightarrow $1, $ \hat Y\rightarrow $2 et $ \hat Z\rightarrow $3.</span><span class="sxs-lookup"><span data-stu-id="315cb-233">In our encoding, the first parameter `Int[]` specifies a Pauli string, where $\hat I\rightarrow 0$, $\hat X\rightarrow 1$, $\hat Y\rightarrow 2$, and $\hat Z\rightarrow 3$.</span></span> <span data-ttu-id="315cb-234">Le deuxième paramètre `Double[]` stocke le coefficient de la chaîne Pauli dans le lieu de la même-Hamilton.</span><span class="sxs-lookup"><span data-stu-id="315cb-234">The second parameter `Double[]` stores the coefficient of the Pauli string in the Hamiltonian.</span></span> <span data-ttu-id="315cb-235">Notez que seul le premier élément de ce tableau est utilisé.</span><span class="sxs-lookup"><span data-stu-id="315cb-235">Note that only the first element of this array is used.</span></span> <span data-ttu-id="315cb-236">Le troisième paramètre `Int[]` indexe le qubits sur lequel cette chaîne Pauli agit, et ne doit pas avoir d’éléments en double.</span><span class="sxs-lookup"><span data-stu-id="315cb-236">The third parameter `Int[]` indexes the qubits that this Pauli string acts on, and must have no duplicate elements.</span></span> <span data-ttu-id="315cb-237">Ainsi, le terme de Hamilton $0,4 \hat X_0 \hat Y_8\hat I_2\hat Z_1 $ peut être représenté comme</span><span class="sxs-lookup"><span data-stu-id="315cb-237">Thus the Hamiltonian term $0.4 \hat X_0 \hat Y_8\hat I_2\hat Z_1$ may be represented as</span></span>

```qsharp
let generatorIndexExample = GeneratorIndex(([1,2,0,3], [0.4]]), [0,8,2,1]);
```

<span data-ttu-id="315cb-238">Le `PauliEvolutionSet()` est une fonction qui mappe n’importe quel `GeneratorIndex` de ce formulaire à un `EvolutionUnitary` avec la signature suivante.</span><span class="sxs-lookup"><span data-stu-id="315cb-238">The `PauliEvolutionSet()` is a function that maps any `GeneratorIndex` of this form to an `EvolutionUnitary` with the following signature.</span></span>

```qsharp
newtype EvolutionUnitary = ((Double, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="315cb-239">Le premier paramètre représente une durée, qui sera multiplié par le coefficient dans le `GeneratorIndex`, de l’évolution unitaire.</span><span class="sxs-lookup"><span data-stu-id="315cb-239">The first parameter represents a time-duration, that will be multiplied by the coefficient in the `GeneratorIndex`, of unitary evolution.</span></span> <span data-ttu-id="315cb-240">Le deuxième paramètre est le qubit inscrit sur lequel agit l’unité.</span><span class="sxs-lookup"><span data-stu-id="315cb-240">The second parameter is the qubit register the unitary acts on.</span></span> 

### <a name="time-dependent-generators"></a><span data-ttu-id="315cb-241">Générateurs dépendants du temps</span><span class="sxs-lookup"><span data-stu-id="315cb-241">Time-Dependent Generators</span></span> ###

<span data-ttu-id="315cb-242">Dans de nombreux cas, nous sommes également intéressés par la modélisation des générateurs dépendants du temps, comme cela peut se produire dans l’équation Schrödinger $ $ \begin{align} i\frac {d \ket{\Psi (t)}} {d t} & = \hat H (t) \ket{\Psi (t)}, \end{align} $ $ où le générateur $ \hat H (t) $ est désormais dépend du temps.</span><span class="sxs-lookup"><span data-stu-id="315cb-242">In many cases, we are also interested in modelling time-dependent generators, as might occur in the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = \hat H(t) \ket{\psi(t)}, \end{align} $$ where the generator $\hat H(t)$ is now time-dependent.</span></span> <span data-ttu-id="315cb-243">L’extension des générateurs indépendants du temps ci-dessus à ce cas est simple.</span><span class="sxs-lookup"><span data-stu-id="315cb-243">The extension from the time-independent generators above to this case is straightforward.</span></span> <span data-ttu-id="315cb-244">Plutôt que d’avoir un `GeneratorSystem` fixe décrivant la Hamilton pour toutes les heures $t $, nous avons plutôt le `GeneratorSystemTimeDependent` type défini par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="315cb-244">Rather than having a fixed `GeneratorSystem` describing the Hamiltonian for all times $t$, we instead have the `GeneratorSystemTimeDependent` user-defined type.</span></span>

```qsharp
newtype GeneratorSystemTimeDependent = (Double -> GeneratorSystem);
```

<span data-ttu-id="315cb-245">Le premier paramètre est un paramètre de planification continue $s \Dans [0, 1] $, et les fonctions de ce type retournent une `GeneratorSystem` pour cette planification.</span><span class="sxs-lookup"><span data-stu-id="315cb-245">The first parameter is a continuous schedule parameter $s\in [0,1]$, and functions of this type return a `GeneratorSystem` for that schedule.</span></span> <span data-ttu-id="315cb-246">Notez que le paramètre de planification peut être lié de manière linéaire au paramètre de temps physique, par exemple $s = t/T $, pour une durée totale de simulation $T $.</span><span class="sxs-lookup"><span data-stu-id="315cb-246">Note that the schedule parameter may be linearly related to the physical time parameter e.g. $s = t / T$, for some total time of simulation $T$.</span></span> <span data-ttu-id="315cb-247">Toutefois, cela n’est pas nécessairement le cas.</span><span class="sxs-lookup"><span data-stu-id="315cb-247">In general however, this need not be the case.</span></span>

<span data-ttu-id="315cb-248">De même, une description complète de ce générateur requiert une `EvolutionSet`et, par conséquent, nous définissons un type `EvolutionSchedule` défini par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="315cb-248">Similarly, a complete description of this generator requires an `EvolutionSet`, and so we define an `EvolutionSchedule` user-defined type.</span></span>

```qsharp
newtype EvolutionSchedule = (EvolutionSet, GeneratorSystemTimeDependent);
```
