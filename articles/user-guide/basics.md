---
title: 'Notions de base sur Q #'
description: 'Concepts de base de Q #'
author: gillenhaalb
ms.author: a-gibec@microsoft.com
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
ms.openlocfilehash: e77b52d1a6eb7e2f62ab12dedd75d00ac8fec4be
ms.sourcegitcommit: a35498492044be4018b4d1b3b611d70a20e77ecc
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 06/03/2020
ms.locfileid: "84327320"
---
# <a name="q-basics"></a><span data-ttu-id="a5dde-103">Notions de base sur Q #</span><span class="sxs-lookup"><span data-stu-id="a5dde-103">Q# Basics</span></span>

<span data-ttu-id="a5dde-104">Dans cette section, nous présentons une brève présentation des blocs de construction de base de Q #.</span><span class="sxs-lookup"><span data-stu-id="a5dde-104">In this section we present a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="a5dde-105">Pour obtenir une vue d’ensemble rapide du Q # et de son emplacement dans un composant fondamental du kit de développement quantique, vous pouvez consulter la section [q # ?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="a5dde-105">For a quick overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, you can check out [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="a5dde-106">Qu’est-ce qu’un programme Quantum ?</span><span class="sxs-lookup"><span data-stu-id="a5dde-106">What is a quantum program?</span></span>

<span data-ttu-id="a5dde-107">D’un point de vue technique, un programme Quantum peut être considéré comme un ensemble particulier de sous-routines classiques qui, lorsqu’il est appelé, effectuent certaines opérations sur un système Quantum.</span><span class="sxs-lookup"><span data-stu-id="a5dde-107">From a technical perspective, a quantum program can be seen as a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="a5dde-108">Une conséquence importante de cette vue est qu’un programme écrit en Q # ne modélise pas directement qubits, mais décrit plutôt comment un ordinateur de contrôle classique interagit avec ces qubits.</span><span class="sxs-lookup"><span data-stu-id="a5dde-108">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="a5dde-109">Par défaut, Q # ne définit pas les États quantiques ou d’autres propriétés de la mécanique de Quantum directement.</span><span class="sxs-lookup"><span data-stu-id="a5dde-109">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="a5dde-110">Par exemple, considérez l’État $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ abordé dans le guide des concepts de l' [informatique Quantum](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="a5dde-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="a5dde-111">Pour préparer cet État dans Q #, nous utilisons les faits que les qubits sont initialisés dans l’État $ \ket {0} $, et que $ \ket{+} = H\ket {0} $, où $H $ est la transformation hadarmard, implémentée par [ `H` opération] (] (XREF : Microsoft. Quantum. Intrinsic. H) :</span><span class="sxs-lookup"><span data-stu-id="a5dde-111">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform, implemented by the [`H` operation](](xref:microsoft.quantum.intrinsic.h):</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0⟩.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0⟩ = |+⟩, as we wanted.
}
```

## <a name="quantum-states-in-q"></a><span data-ttu-id="a5dde-112">États de Quantum dans Q #</span><span class="sxs-lookup"><span data-stu-id="a5dde-112">Quantum states in Q#</span></span>

<span data-ttu-id="a5dde-113">Important, en écrivant le programme ci-dessus, nous n’avons pas explicitement fait référence à l’État dans Q #, mais nous avons décrit la façon dont l’État a été *transformé* par notre programme.</span><span class="sxs-lookup"><span data-stu-id="a5dde-113">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="a5dde-114">Cela nous permet d’être totalement agnostique quant à ce qu' *est* un État Quantum sur chaque ordinateur cible, qui peut avoir des interprétations différentes en fonction de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="a5dde-114">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="a5dde-115">Un programme Q # n’a pas la possibilité d’inverser l’état d’un qubit.</span><span class="sxs-lookup"><span data-stu-id="a5dde-115">A Q# program has no ability to introspect into the state of a qubit.</span></span>
<span data-ttu-id="a5dde-116">Au lieu de cela, un programme peut appeler des opérations telles que [`Measure`](xref:microsoft.quantum.intrinsic.measure) pour obtenir des informations à partir d’un qubit et appeler des opérations telles que [`X`](xref:microsoft.quantum.intrinsic.x) et [`H`](xref:microsoft.quantum.intrinsic.h) pour agir sur l’état d’un qubit.</span><span class="sxs-lookup"><span data-stu-id="a5dde-116">Rather, a program can call operations such as [`Measure`](xref:microsoft.quantum.intrinsic.measure) to learn information from a qubit, and call operations such as [`X`](xref:microsoft.quantum.intrinsic.x) and [`H`](xref:microsoft.quantum.intrinsic.h) to act on the state of a qubit.</span></span>
<span data-ttu-id="a5dde-117">Ce que *font* réellement ces opérations n’est rendu concrète que par l’ordinateur cible que nous utilisons pour exécuter le programme Q # en particulier.</span><span class="sxs-lookup"><span data-stu-id="a5dde-117">What these operations actually *do* is only made concrete by the target machine we use to run the particular Q# program.</span></span>
<span data-ttu-id="a5dde-118">Par exemple, si vous exécutez le programme sur notre [simulateur d’état complet](xref:microsoft.quantum.machines.full-state-simulator), le simulateur effectuera les opérations mathématiques correspondantes sur le système Quantum simulé.</span><span class="sxs-lookup"><span data-stu-id="a5dde-118">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator will perform the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="a5dde-119">Mais en regardant dans le futur, lorsque l’ordinateur cible est un ordinateur Quantum réel, l’appel de ces opérations dans Q # indiquera à l’ordinateur Quantum d’effectuer les opérations *réelles* correspondantes sur le système Quantum *réel* (par exemple, des impulsions laser avec des minutages précis).</span><span class="sxs-lookup"><span data-stu-id="a5dde-119">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# will direct the quantum computer to perform the corresponding *real* operations on the *real* quantum system (e.g. precisely timed laser pulses).</span></span>

<span data-ttu-id="a5dde-120">Un programme Q # regroupe ces opérations comme défini par un ordinateur cible pour créer des opérations de niveau supérieur pour exprimer le calcul Quantum.</span><span class="sxs-lookup"><span data-stu-id="a5dde-120">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="a5dde-121">De cette façon, Q # permet d’exprimer facilement les algorithmes Quantum et Quantum hybrides de logique sous-jacents, tout en étant également général en ce qui concerne la structure d’un ordinateur cible ou d’un simulateur.</span><span class="sxs-lookup"><span data-stu-id="a5dde-121">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="a5dde-122">Opérations et fonctions Q #</span><span class="sxs-lookup"><span data-stu-id="a5dde-122">Q# operations and functions</span></span>

<span data-ttu-id="a5dde-123">Concrètement, un programme Q # est constitué d' *opérations*, de *fonctions*et de tous les types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="a5dde-123">Concretely, a Q# program is comprised of *operations*, *functions*, and any user-defined types.</span></span> 

<span data-ttu-id="a5dde-124">Les opérations sont utilisées pour décrire les transformations des systèmes quantiques et constituent le bloc de construction le plus basique des programmes Q #.</span><span class="sxs-lookup"><span data-stu-id="a5dde-124">Operations are used to describe the transformations of quantum systems and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="a5dde-125">Chaque opération définie dans Q # peut alors appeler un nombre quelconque d’autres opérations.</span><span class="sxs-lookup"><span data-stu-id="a5dde-125">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="a5dde-126">Contrairement aux opérations, les fonctions sont utilisées pour décrire le comportement classique purement *déterministe* et n’ont pas d’effets en plus des valeurs classiques de calcul.</span><span class="sxs-lookup"><span data-stu-id="a5dde-126">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="a5dde-127">Supposons, par exemple, que nous souhaitons mesurer notre qubits à la fin d’un programme et ajouter les résultats des mesures à un tableau.</span><span class="sxs-lookup"><span data-stu-id="a5dde-127">For example, suppose we would like to measure our qubits at the end of a program, and add the measurement results to an array.</span></span>
<span data-ttu-id="a5dde-128">Dans ce cas `Measure` , il s’agit d’une *opération* qui indique à l’ordinateur cible d’effectuer une mesure sur le qubits (réel ou simulé), et le processus classique d’ajout des résultats retournés à un tableau sera géré par les *fonctions*.</span><span class="sxs-lookup"><span data-stu-id="a5dde-128">In this case `Measure` is an *operation* which instructs the target machine to perform a measurement on the (real or simulated) qubits, and the classical process of adding the returned results to an array will be handled by *functions*.</span></span>

<span data-ttu-id="a5dde-129">Ensemble, les opérations et les fonctions sont appelées *callables*, et leur structure et comportement sous-jacents est introduit sur les [opérations et les fonctions dans la page Q #](xref:microsoft.quantum.guide.operationsfunctions) .</span><span class="sxs-lookup"><span data-stu-id="a5dde-129">Together, operations and functions are referred to as *callables*, and their underlying structure and behavior is introduced on the [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions) page.</span></span>


## <a name="q-syntax-overview"></a><span data-ttu-id="a5dde-130">Vue d’ensemble de la syntaxe Q #</span><span class="sxs-lookup"><span data-stu-id="a5dde-130">Q# syntax overview</span></span>

<span data-ttu-id="a5dde-131">La syntaxe d’un langage décrit les différentes combinaisons de symboles qui forment un programme syntaxiquement correct.</span><span class="sxs-lookup"><span data-stu-id="a5dde-131">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="a5dde-132">Dans Q #, nous pouvons classer les éléments de sa syntaxe dans trois groupes différents : les types, les expressions et les instructions.</span><span class="sxs-lookup"><span data-stu-id="a5dde-132">In Q# we can classify the elements of its syntax in three different groups: types, expressions and statements.</span></span>

### <a name="types"></a><span data-ttu-id="a5dde-133">Types</span><span class="sxs-lookup"><span data-stu-id="a5dde-133">Types</span></span>
<span data-ttu-id="a5dde-134">Q # est un langage fortement typé, de sorte que l’utilisation soigneuse des types peut aider le compilateur à fournir des garanties fortes sur les programmes Q # au moment de la compilation.</span><span class="sxs-lookup"><span data-stu-id="a5dde-134">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="a5dde-135">En plus des types primitifs intégrés spécifiques à Quantum et standard (par exemple, `Int` , `Bool` `Qubit` et `Result` ), Q # fournit la prise en charge des types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="a5dde-135">In addition to standard and quantum-specific built-in primitive types (e.g. `Int`, `Bool`, `Qubit`, and `Result`), Q# provides support for user-defined types.</span></span>
<span data-ttu-id="a5dde-136">Tous les types primitifs de Q # sont décrits sur la page [types dans q #](xref:microsoft.quantum.guide.types) , ainsi que des détails sur les types de tableau et de tuple, ainsi que sur la façon de définir de nouveaux types dans un fichier q #.</span><span class="sxs-lookup"><span data-stu-id="a5dde-136">All of Q#'s various primitive types are described on the [Types in Q#](xref:microsoft.quantum.guide.types) page, along with details on array and tuple types, as well as how to define new types within a Q# file.</span></span>

### <a name="expressions"></a><span data-ttu-id="a5dde-137">Expressions</span><span class="sxs-lookup"><span data-stu-id="a5dde-137">Expressions</span></span>
<span data-ttu-id="a5dde-138">Une expression dans un langage de programmation est une combinaison d’une ou de plusieurs constantes, variables, opérateurs et fonctions que le langage de programmation interprète et évalue à une valeur spécifique.</span><span class="sxs-lookup"><span data-stu-id="a5dde-138">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="a5dde-139">Plus simplement, pour chaque type dans un langage, les expressions de ce type peuvent être des *littéraux* ou des symboles liés à une valeur de ce type.</span><span class="sxs-lookup"><span data-stu-id="a5dde-139">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="a5dde-140">Par exemple, `5` est un `Int` littéral (donc également une expression de type `Int` ), et si le symbole `count` est lié à la valeur entière `5` , `count` est également une expression entière.</span><span class="sxs-lookup"><span data-stu-id="a5dde-140">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="a5dde-141">En outre, une expression peut être constituée d’autres expressions associées à certains opérateurs.</span><span class="sxs-lookup"><span data-stu-id="a5dde-141">Additionally, an expression can consist of other expressions combined with certain operators.</span></span>
<span data-ttu-id="a5dde-142">Par conséquent, un autre exemple d' `Int` expression qui prend la valeur `5` est `2+3` .</span><span class="sxs-lookup"><span data-stu-id="a5dde-142">Hence another example of an `Int` expression which evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="a5dde-143">Les expressions possibles de types dans Q #, ainsi que les opérateurs compatibles qui peuvent être utilisés pour les former, sont détaillées sur les [expressions de type dans la page Q #](xref:microsoft.quantum.guide.expressions) .</span><span class="sxs-lookup"><span data-stu-id="a5dde-143">The possible expressions of types in Q#, as well as the compatible operators that can be used to form them, are detailed on the [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions) page.</span></span> 

### <a name="statements"></a><span data-ttu-id="a5dde-144">Instructions</span><span class="sxs-lookup"><span data-stu-id="a5dde-144">Statements</span></span> 
<span data-ttu-id="a5dde-145">Une instruction est une unité syntaxique d’un langage de programmation impérative qui exprime une action à effectuer. Les instructions contrastent avec les expressions dans les instructions qui ne retournent pas de résultats et qui sont exécutées uniquement pour leurs effets secondaires, tandis que les expressions retournent toujours un résultat et n’ont souvent pas d’effets secondaires.</span><span class="sxs-lookup"><span data-stu-id="a5dde-145">A statement is a syntactic unit of an imperative programming language that expresses some action to be carried out. Statements contrast with expressions in that statements do not return results and are executed solely for their side effects, while expressions always return a result and often do not have side effects at all.</span></span>
<span data-ttu-id="a5dde-146">Cette distinction est fréquemment observée dans le libellé : une expression est évaluée, tandis qu’une instruction est exécutée.</span><span class="sxs-lookup"><span data-stu-id="a5dde-146">This distinction is frequently observed in wording: an expression is evaluated, whereas a statement is executed.</span></span>

<span data-ttu-id="a5dde-147">Un exemple très basique d’une instruction dans Q # consiste à assigner un symbole à une expression :</span><span class="sxs-lookup"><span data-stu-id="a5dde-147">A very basic example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="a5dde-148">Un exemple légèrement plus intéressant est l' `for` instruction qui prend en charge l’itération et qui comprend un *bloc d’instructions*.</span><span class="sxs-lookup"><span data-stu-id="a5dde-148">A slightly more interesting example is the `for` statement which supports iteration and includes a *statement block*.</span></span>
<span data-ttu-id="a5dde-149">Supposons que `qubits` le symbole est lié à un registre de qubits (techniquement de type `Qubit[]` , c’est-à-dire un tableau de `Qubit` types).</span><span class="sxs-lookup"><span data-stu-id="a5dde-149">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, i.e. an array of `Qubit` types).</span></span> <span data-ttu-id="a5dde-150">Alors</span><span class="sxs-lookup"><span data-stu-id="a5dde-150">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="a5dde-151">est une instruction qui itère au sein de chaque qubit dans le registre, en effectuant l' `H` opération sur chacun.</span><span class="sxs-lookup"><span data-stu-id="a5dde-151">is a statement which iterates over each qubit in the register, performing the `H` operation on each.</span></span> <span data-ttu-id="a5dde-152">Notez `H(qubit);` également qu’il s’agit d’une instruction.</span><span class="sxs-lookup"><span data-stu-id="a5dde-152">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="a5dde-153">En fait, toute expression d’appel de type `Unit` (ces callables qui ne retournent aucune information) peut être utilisée comme une instruction.</span><span class="sxs-lookup"><span data-stu-id="a5dde-153">In fact, any call expression of type `Unit` (those callables that do not return any information) may be used as a statement.</span></span>
<span data-ttu-id="a5dde-154">Cela est principalement utilisé lors de l’appel d’opérations sur des qubits qui retournent parce que l' `Unit` objectif de l’instruction est de modifier l’État Quantum implicite.</span><span class="sxs-lookup"><span data-stu-id="a5dde-154">This is primarily of use when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="a5dde-155">Les instructions d’évaluation d’expression requièrent un point-virgule de fin.</span><span class="sxs-lookup"><span data-stu-id="a5dde-155">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="a5dde-156">Presque tous les aspects d’un programme Q # sont générés à l’aide d’instructions, donc aucune page ne peut englober toutes les informations qui s’y rapportent.</span><span class="sxs-lookup"><span data-stu-id="a5dde-156">Nearly every aspect of a Q# program is built using statements, so no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="a5dde-157">Toutefois, leur structure lexicale et leur mise en forme sont décrites sur la page de [structure de fichier q #](xref:microsoft.quantum.guide.filestructure) , l’assignation de liaison de symboles et la portée aux [variables dans q #](xref:microsoft.quantum.guide.variables), et les boucles de workflow de contrôle telles que `for` at [Control flow in Q #](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="a5dde-157">However, their lexical structure and formatting is described on the [Q# File Structure](xref:microsoft.quantum.guide.filestructure) page, symbol binding assignment and scope at [Variables in Q#](xref:microsoft.quantum.guide.variables), and control flow loops such as `for` at [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="a5dde-158">Étapes suivantes</span><span class="sxs-lookup"><span data-stu-id="a5dde-158">Next steps</span></span>
<span data-ttu-id="a5dde-159">Dans le reste de ce guide, nous vous montrerons comment utiliser Q # pour créer des programmes quantiques complexes à l’aide des blocs de construction de base des opérations, des fonctions et des types.</span><span class="sxs-lookup"><span data-stu-id="a5dde-159">Throughout the rest of this guide, we will show you how to use Q# to construct complex quantum programs through the basic building blocks of operations, functions, and types.</span></span>

<span data-ttu-id="a5dde-160">Pour commencer, vous pouvez commencer à vous familiariser [avec les types dans Q #](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="a5dde-160">To get started, you can start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="a5dde-161">Si vous souhaitez en savoir plus sur les fondations et la motivation de Q #, découvrez [pourquoi nous avons besoin de q # ?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="a5dde-161">If you are interested in learning more about the foundations and motivation behind Q#, check out [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
