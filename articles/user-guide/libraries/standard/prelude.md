---
title: Opérations et fonctions intrinsèques dans QDK
description: En savoir plus sur les opérations et les fonctions intrinsèques dans le QDK, y compris les fonctions classiques et les opérations d’unité, de rotation et de mesure.
author: QuantumWriter
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.prelude
no-loc:
- Q#
- $$v
ms.openlocfilehash: 4eb10e82a64381c503703be440be90e60f3a8622
ms.sourcegitcommit: 75c4edc7c410cc63dc8352e2a5bef44b433ed188
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/25/2020
ms.locfileid: "88863723"
---
# <a name="the-prelude"></a><span data-ttu-id="4b8f4-103">Préambule destiné à</span><span class="sxs-lookup"><span data-stu-id="4b8f4-103">The Prelude</span></span> #

<span data-ttu-id="4b8f4-104">Le Q# compilateur et les ordinateurs cibles inclus avec le kit de développement Quantum fournissent un ensemble de fonctions et d’opérations intrinsèques qui peuvent être utilisées lors de l’écriture de programmes de Quantum dans Q# .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-104">The Q# compiler and the target machines included with the Quantum Development Kit provide a set of intrinsic functions and operations that can be used when writing quantum programs in Q#.</span></span>

## <a name="intrinsic-operations-and-functions"></a><span data-ttu-id="4b8f4-105">Opérations et fonctions intrinsèques</span><span class="sxs-lookup"><span data-stu-id="4b8f4-105">Intrinsic Operations and Functions</span></span> ##

<span data-ttu-id="4b8f4-106">Les opérations intrinsèques définies dans la bibliothèque standard appartiennent approximativement à l’une des catégories suivantes :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-106">The intrinsic operations defined in the standard library roughly fall into one of several categories:</span></span>

- <span data-ttu-id="4b8f4-107">Fonctions classiques essentielles, collectées dans l' <xref:microsoft.quantum.core> espace de noms.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-107">Essential classical functions, collected in the <xref:microsoft.quantum.core> namespace.</span></span>
- <span data-ttu-id="4b8f4-108">Opérations représentant des unités de [Clifford et de $T $ Gates](xref:microsoft.quantum.concepts.qubit).</span><span class="sxs-lookup"><span data-stu-id="4b8f4-108">Operations representing unitaries composed of [Clifford and $T$ gates](xref:microsoft.quantum.concepts.qubit).</span></span>
- <span data-ttu-id="4b8f4-109">Opérations représentant des rotations sur différents opérateurs.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-109">Operations representing rotations about various operators.</span></span>
- <span data-ttu-id="4b8f4-110">Opérations mettant en œuvre des mesures.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-110">Operations implementing measurements.</span></span>

<span data-ttu-id="4b8f4-111">Étant donné que l’ensemble de portes Clifford + $T $ est [universel](xref:microsoft.quantum.concepts.multiple-qubits) pour le quantum computing, ces opérations suffisent à implémenter n’importe quel algorithme Quantum dans une petite erreur negligibly.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-111">Since the Clifford + $T$ gate set is [universal](xref:microsoft.quantum.concepts.multiple-qubits) for quantum computing, these operations suffice to approximately implement any quantum algorithm within negligibly small error.</span></span>
<span data-ttu-id="4b8f4-112">En fournissant également des rotations, Q# permet au programmeur de travailler au sein de la bibliothèque qubit Unity et cnotin Gate unique.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-112">By providing rotations as well, Q# allows the programmer to work within the single qubit unitary and CNOT gate library.</span></span> <span data-ttu-id="4b8f4-113">Cette bibliothèque est beaucoup plus facile à réfléchir, car elle ne nécessite pas que le programmeur n’exprime directement la décomposition Clifford + $T $ et que des méthodes très efficaces existent pour compiler des unités qubit uniques dans Clifford et $T $ Gates (voir [ici](xref:microsoft.quantum.more-information) pour plus d’informations).</span><span class="sxs-lookup"><span data-stu-id="4b8f4-113">This library is much easier to think about because it does not  require the programmer to directly express the Clifford + $T$ decomposition and because highly efficient methods exist for compiling single qubit unitaries into Clifford and $T$ gates (see [here](xref:microsoft.quantum.more-information) for more information).</span></span>

<span data-ttu-id="4b8f4-114">Dans la mesure du possible, les opérations définies dans le préambule destiné à qui agissent sur qubits autorisent l’application de la `Controlled` variante, de telle sorte que l’ordinateur cible effectue la décomposition appropriée.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-114">Where possible, the operations defined in the prelude which act on qubits allow for applying the `Controlled` variant, such that the target machine will perform the appropriate decomposition.</span></span>

<span data-ttu-id="4b8f4-115">La plupart des fonctions et opérations définies dans cette partie du préambule destiné à se trouvent dans l' @"microsoft.quantum.intrinsic" espace de noms, de telle sorte que la plupart des Q# fichiers sources auront une `open Microsoft.Quantum.Intrinsic;` directive immédiatement après la déclaration d’espace de noms initiale.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-115">Many of the functions and operations defined in this portion of the prelude are in the @"microsoft.quantum.intrinsic" namespace, such that most Q# source files will have an `open Microsoft.Quantum.Intrinsic;` directive immediately following the initial namespace declaration.</span></span>
<span data-ttu-id="4b8f4-116">L' <xref:microsoft.quantum.core> espace de noms s’ouvre automatiquement, de sorte que les fonctions telles que <xref:microsoft.quantum.core.length> peuvent être utilisées sans `open` instruction.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-116">The <xref:microsoft.quantum.core> namespace is automatically opened, so that functions such as <xref:microsoft.quantum.core.length> can be used without an `open` statement at all.</span></span>

### <a name="common-single-qubit-unitary-operations"></a><span data-ttu-id="4b8f4-117">Opérations courantes d’unités qubit simples</span><span class="sxs-lookup"><span data-stu-id="4b8f4-117">Common Single-Qubit Unitary Operations</span></span> ###

<span data-ttu-id="4b8f4-118">Préambule destiné à définit également de nombreuses [opérations courantes à qubit unique](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span><span class="sxs-lookup"><span data-stu-id="4b8f4-118">The prelude also defines many common [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations).</span></span>
<span data-ttu-id="4b8f4-119">Toutes ces opérations autorisent à la fois les `Controlled` `Adjoint` functors et.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-119">All of these operations allow both the `Controlled` and `Adjoint` functors.</span></span>

#### <a name="pauli-operators"></a><span data-ttu-id="4b8f4-120">Pauli, opérateurs</span><span class="sxs-lookup"><span data-stu-id="4b8f4-120">Pauli Operators</span></span> ####

<span data-ttu-id="4b8f4-121">L' <xref:microsoft.quantum.intrinsic.x> opération implémente l’opérateur Pauli $X $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-121">The <xref:microsoft.quantum.intrinsic.x> operation implements the Pauli $X$ operator.</span></span>
<span data-ttu-id="4b8f4-122">C’est ce que l’on appelle parfois la `NOT` porte.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-122">This is sometimes also known as the `NOT` gate.</span></span>
<span data-ttu-id="4b8f4-123">Il possède une signature `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-123">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-124">Il correspond à l’unité qubit unique :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-124">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="4b8f4-125">\begin{Equation} \begin{bmatrix} 0 & 1 \\ \\ % correctif : cela utilise actuellement le pirate quadwhack.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-125">\begin{equation} \begin{bmatrix} 0 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="4b8f4-126">1 & 0 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="4b8f4-126">1 & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="4b8f4-127">L' <xref:microsoft.quantum.intrinsic.y> opération implémente l’opérateur Pauli $Y $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-127">The <xref:microsoft.quantum.intrinsic.y> operation implements the Pauli $Y$ operator.</span></span>
<span data-ttu-id="4b8f4-128">Il possède une signature `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-128">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-129">Il correspond à l’unité qubit unique :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-129">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="4b8f4-130">\begin{Equation} \begin{bmatrix} 0 &-i \\ \\ % correctif : cela utilise actuellement le quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-130">\begin{equation} \begin{bmatrix} 0 & -i \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="4b8f4-131">i & 0 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="4b8f4-131">i & 0 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="4b8f4-132">L' <xref:microsoft.quantum.intrinsic.z> opération implémente l’opérateur Pauli $Z $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-132">The <xref:microsoft.quantum.intrinsic.z> operation implements the Pauli $Z$ operator.</span></span>
<span data-ttu-id="4b8f4-133">Il possède une signature `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-133">It has signature `(Qubit => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-134">Il correspond à l’unité qubit unique :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-134">It corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="4b8f4-135">\begin{Equation} \begin{bmatrix} 1 & 0 \\ \\ % corriger : utilise actuellement le quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-135">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="4b8f4-136">0 &-1 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="4b8f4-136">0 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="4b8f4-137">Ci-dessous, nous voyons ces transformations mappées à la [sphère Bloch](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (l’axe de rotation dans chaque cas est surligné en rouge) :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-137">Below we see these transformations mapped to the [Bloch sphere](xref:microsoft.quantum.concepts.qubit#visualizing-qubits-and-transformations-using-the-bloch-sphere) (the rotation axis in each case is highlighted red):</span></span>

![Opérations Pauli mappées sur la sphère Bloch](~/media/prelude_pauliBloch.png)

<span data-ttu-id="4b8f4-139">Il est important de noter que l’application du même portail Pauli deux fois au même qubit annule l’opération (car vous avez maintenant effectué une rotation complète de 2π (360 °) sur la surface vers la sphère Bloch, ce qui revient au point de départ).</span><span class="sxs-lookup"><span data-stu-id="4b8f4-139">It is important to note that applying the same Pauli gate twice to the same qubit cancels out the operation (because you have now performed a full rotation of 2π (360°) over the surface to the Bloch Sphere, thus arriving back at the starting point).</span></span> <span data-ttu-id="4b8f4-140">Cela nous amène à l’identité suivante :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-140">This brings us to the following identity:</span></span>

<span data-ttu-id="4b8f4-141">$ $ X ^ 2 = Y ^ 2 = Z ^ 2 = \boldone $ $</span><span class="sxs-lookup"><span data-stu-id="4b8f4-141">$$ X^2=Y^2=Z^2=\boldone $$</span></span>

<span data-ttu-id="4b8f4-142">Cela peut être visualisé sur la sphère Bloch :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-142">This can be visualised on the Bloch sphere:</span></span>

![XX = I](~/media/prelude_blochIdentity.png)

#### <a name="other-single-qubit-cliffords"></a><span data-ttu-id="4b8f4-144">Autre Cliffords à qubit unique</span><span class="sxs-lookup"><span data-stu-id="4b8f4-144">Other Single-Qubit Cliffords</span></span> ####

<span data-ttu-id="4b8f4-145">L' <xref:microsoft.quantum.intrinsic.h> opération implémente la porte hadarmard.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-145">The <xref:microsoft.quantum.intrinsic.h> operation implements the Hadamard gate.</span></span>
<span data-ttu-id="4b8f4-146">Cela Interchange les axes Pauli $X $ et $Z $ du qubit cible, de telle sorte que $H \ket {0} = \ket{+} \mathrel{ : =} (\ket {0} + \ket {1} )/\sqrt {2} $ et $H \ket{+} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-146">This interchanges the Pauli $X$ and $Z$ axes of the target qubit, such that $H\ket{0} = \ket{+} \mathrel{:=} (\ket{0} + \ket{1}) / \sqrt{2}$ and $H\ket{+} = \ket{0}$.</span></span>
<span data-ttu-id="4b8f4-147">Il possède `(Qubit => Unit is Adj + Ctl)` une signature et correspond à l’unité qubit unique :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-147">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="4b8f4-148">\begin{Equation} \frac {1} {\sqrt {2} } \begin{bmatrix} 1 & 1 \\ \\ % correctif : cela utilise actuellement le piratage quadwhack.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-148">\begin{equation} \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="4b8f4-149">1 &-1 \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="4b8f4-149">1 & -1 \end{bmatrix} \end{equation}</span></span>

<span data-ttu-id="4b8f4-150">La porte Hadarmard est particulièrement importante, car elle peut être utilisée pour créer une superposition des États $ \ket {0} $ et $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-150">The Hadamard gate is particularly important as it can be used to create a superposition of the $\ket{0}$ and $\ket{1}$ states.</span></span> <span data-ttu-id="4b8f4-151">Dans la représentation Bloch Sphere, il est plus facile de considérer cela comme une rotation de $ \ket{\Psi} $ autour de l’axe x par $ \pi $ radians ($ 180 ^ \circ $) suivi d’une rotation (dans le sens des aiguilles d’une montre) autour de l’axe y par $ \ pi/2 $ radians ($ 90 ^ \circ $) :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-151">In the Bloch sphere representation, it is easiest to think of this as a rotation of $\ket{\psi}$ around the x-axis by $\pi$ radians ($180^\circ$) followed by a (clockwise) rotation around the y-axis by $\pi/2$ radians ($90^\circ$):</span></span>

![Opération hadarmard mappée sur la sphère Bloch](~/media/prelude_hadamardBloch.png)

<span data-ttu-id="4b8f4-153">L' <xref:microsoft.quantum.intrinsic.s> opération implémente la porte de phase $S $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-153">The <xref:microsoft.quantum.intrinsic.s> operation implements the phase gate $S$.</span></span>
<span data-ttu-id="4b8f4-154">Il s’agit de la racine carrée de la matrice de l’opération Pauli $Z $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-154">This is the matrix square root of the Pauli $Z$ operation.</span></span>
<span data-ttu-id="4b8f4-155">Autrement dit, $S ^ 2 = Z $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-155">That is, $S^2 = Z$.</span></span>
<span data-ttu-id="4b8f4-156">Il possède `(Qubit => Unit is Adj + Ctl)` une signature et correspond à l’unité qubit unique :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-156">It has signature `(Qubit => Unit is Adj + Ctl)`, and corresponds to the single-qubit unitary:</span></span>

<span data-ttu-id="4b8f4-157">\begin{Equation} \begin{bmatrix} 1 & 0 \\ \\ % corriger : utilise actuellement le quadwhack hack.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-157">\begin{equation} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quadwhack hack.</span></span>
<span data-ttu-id="4b8f4-158">0 & \end{bmatrix} \end{Equation}</span><span class="sxs-lookup"><span data-stu-id="4b8f4-158">0 & i \end{bmatrix} \end{equation}</span></span>

#### <a name="rotations"></a><span data-ttu-id="4b8f4-159">Roulements</span><span class="sxs-lookup"><span data-stu-id="4b8f4-159">Rotations</span></span> ####

<span data-ttu-id="4b8f4-160">En plus des opérations Pauli et Clifford ci-dessus, le Q# préambule destiné à fournit diverses façons d’exprimer des rotations.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-160">In addition to the Pauli and Clifford operations above, the Q# prelude provides a variety of ways of expressing rotations.</span></span>
<span data-ttu-id="4b8f4-161">Comme décrit dans [opérations à qubit unique](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), la possibilité d’effectuer une rotation est essentielle aux algorithmes Quantum.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-161">As described in [single-qubit operations](xref:microsoft.quantum.concepts.qubit#single-qubit-operations), the ability to rotate is critical to quantum algorithms.</span></span>

<span data-ttu-id="4b8f4-162">Nous commençons par rappeler que nous pouvons exprimer une opération à qubit unique à l’aide de la $H $ et $T $ Gates, où $H $ est l’opération Hadarmard, et où \begin{Equation} T \mathrel{ : =} \begin{bmatrix} 1 & 0 \\ \\ % corriger : cette valeur utilise actuellement le pirate Quad Back Whack.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-162">We start by recalling that we can express any single-qubit operation using the $H$ and $T$ gates, where $H$ is the Hadamard operation, and where \begin{equation} T \mathrel{:=} \begin{bmatrix} 1 & 0 \\\\ % FIXME: this currently uses the quad back whack hack.</span></span>
<span data-ttu-id="4b8f4-163">0 & e ^ {i \pi/4} \end{bmatrix} \end{Equation} il s’agit de la racine carrée de l' <xref:microsoft.quantum.intrinsic.s> opération, par exemple $T ^ 2 = S $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-163">0 & e^{i \pi / 4} \end{bmatrix} \end{equation} This is the square root of the <xref:microsoft.quantum.intrinsic.s> operation, such that $T^2 = S$.</span></span>
<span data-ttu-id="4b8f4-164">Le $T $ Gate est à son tour implémenté par l' <xref:microsoft.quantum.intrinsic.t> opération, et possède la signature `(Qubit => Unit is Adj + Ctl)` , indiquant qu’il s’agit d’une opération d’unité sur un qubit unique.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-164">The $T$ gate is in turn implemented by the <xref:microsoft.quantum.intrinsic.t> operation, and has signature `(Qubit => Unit is Adj + Ctl)`, indicating that it is a unitary operation on a single-qubit.</span></span>

<span data-ttu-id="4b8f4-165">Même si cela est en principe suffisant pour décrire une opération arbitraire à qubit unique, les différentes machines cibles peuvent avoir des représentations plus efficaces pour les rotations sur les opérateurs Pauli, de sorte que le préambule destiné à comprend de nombreuses façons de convienently exprimer ces rotations.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-165">Even though this is in principle sufficient to describe any arbitrary single-qubit operation, different target machines may have more efficient representations for rotations about Pauli operators, such that the prelude includes a variety of ways to convienently express such rotations.</span></span>
<span data-ttu-id="4b8f4-166">Le plus simple est l' <xref:microsoft.quantum.intrinsic.r> opération, qui implémente une rotation autour d’un axe Pauli spécifié, \Begin{Equation} R (\sigma, \Phi) \mathrel{ : =} \exp (-i \Phi \sigma/2), \end{Equation} où $ \sigma $ est un opérateur Pauli, $ \Phi $ est un angle et où $ \exp $ représente l’exponentiel de la matrice.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-166">The most basic of these is the <xref:microsoft.quantum.intrinsic.r> operation, which implements a rotation around a specified Pauli axis, \begin{equation} R(\sigma, \phi) \mathrel{:=} \exp(-i \phi \sigma / 2), \end{equation} where $\sigma$ is a Pauli operator, $\phi$ is an angle, and where $\exp$ represents the matrix exponential.</span></span>
<span data-ttu-id="4b8f4-167">Elle possède une signature `((Pauli, Double, Qubit) => Unit is Adj + Ctl)` , où les deux premières parties de l’entrée représentent les arguments classiques $ \sigma $ et $ \Phi $ requis pour spécifier l’opérateur unitaire $R (\sigma, \Phi) $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-167">It has signature `((Pauli, Double, Qubit) => Unit is Adj + Ctl)`, where the first two parts of the input represent the classical arguments $\sigma$ and $\phi$ needed to specify the unitary operator $R(\sigma, \phi)$.</span></span>
<span data-ttu-id="4b8f4-168">Nous pouvons appliquer partiellement $ \sigma $ et $ \Phi $ pour obtenir une opération dont le type est celui d’une unité qubit unique.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-168">We can partially apply $\sigma$ and $\phi$ to obtain an operation whose type is that of a single-qubit unitary.</span></span>
<span data-ttu-id="4b8f4-169">Par exemple, `R(PauliZ, PI() / 4, _)` a le type `(Qubit => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-169">For example, `R(PauliZ, PI() / 4, _)` has type `(Qubit => Unit is Adj + Ctl)`.</span></span>

> [!NOTE]
> <span data-ttu-id="4b8f4-170">L' <xref:microsoft.quantum.intrinsic.r> opération divise l’angle d’entrée par 2 et le multiplie par-1.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-170">The <xref:microsoft.quantum.intrinsic.r> operation divides the input angle by 2 and multiplies it by -1.</span></span>
> <span data-ttu-id="4b8f4-171">Pour $Z $ rotations, cela signifie que $ \ket {0} $ eigenstate est pivoté par $-\Phi/$2 et que $ \ket {1} $ eigenstate est pivoté par $ \phi/$2, de sorte que le \ket $ eigenstate {1} $ est pivoté par $ \Phi $ par rapport au $ \ket {0} $ eigenstate.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-171">For $Z$ rotations, this means that the $\ket{0}$ eigenstate is rotated by $-\phi / 2$ and the $\ket{1}$ eigenstate is rotated by $\phi / 2$, so that the $\ket{1}$ eigenstate is rotated by $\phi$ relative to the $\ket{0}$ eigenstate.</span></span>
>
> <span data-ttu-id="4b8f4-172">En particulier, cela signifie que `T` et `R(PauliZ, PI() / 8, _)` diffère uniquement par une [phase globale](xref:microsoft.quantum.glossary#global-phase)non pertinente.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-172">In particular, this means that `T` and `R(PauliZ, PI() / 8, _)` differ only by an irrelevant [global phase](xref:microsoft.quantum.glossary#global-phase).</span></span>
> <span data-ttu-id="4b8f4-173">C’est la raison pour laquelle $T $ est parfois appelé $ \frac{\pi} {8} $-Gate.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-173">For this reason, $T$ is sometimes known as the $\frac{\pi}{8}$-gate.</span></span>
>
> <span data-ttu-id="4b8f4-174">Notez également que la rotation autour `PauliI` applique simplement une phase globale de $ \Phi/$2.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-174">Note also that rotating around `PauliI` simply applies a global phase of $\phi / 2$.</span></span> <span data-ttu-id="4b8f4-175">Ces phases ne sont pas pertinentes, comme dans [les documents conceptuels](xref:microsoft.quantum.concepts.qubit), elles sont pertinentes pour les `PauliI` rotations contrôlées.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-175">While such phases are irrelevant, as argued in [the conceptual documents](xref:microsoft.quantum.concepts.qubit), they are relevant for controlled `PauliI` rotations.</span></span>

<span data-ttu-id="4b8f4-176">Dans les algorithmes Quantum, il est souvent utile d’exprimer des rotations en tant que fractions dyadic, de sorte que $ \Phi = \pi k/2 ^ n $ pour certains $k \Dans \mathbb{Z} $ et $n \Dans \mathbb{N} $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-176">Within quantum algorithms, it is often useful to express rotations as dyadic fractions, such that $\phi = \pi k / 2^n$ for some $k \in \mathbb{Z}$ and $n \in \mathbb{N}$.</span></span>
<span data-ttu-id="4b8f4-177">L' <xref:microsoft.quantum.intrinsic.rfrac> opération implémente une rotation autour d’un axe Pauli spécifié à l’aide de cette Convention.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-177">The <xref:microsoft.quantum.intrinsic.rfrac> operation implements a rotation around a specified Pauli axis using this convention.</span></span>
<span data-ttu-id="4b8f4-178">Il diffère de <xref:microsoft.quantum.intrinsic.r> en ce que l’angle de rotation est spécifié sous la forme de deux entrées de type `Int` , interprétées comme une fraction dyadic.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-178">It differs from <xref:microsoft.quantum.intrinsic.r> in that the rotation angle is specified as two inputs of type `Int`, interpreted as a dyadic fraction.</span></span>
<span data-ttu-id="4b8f4-179">Par conséquent, `RFrac` possède une signature `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-179">Thus, `RFrac` has signature `((Pauli, Int, Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-180">Il implémente le qubit unitaire $ \exp (i \pi k \sigma/2 ^ n) $, où $ \sigma $ est la matrice Pauli correspondant au premier argument, $k $ est le deuxième argument et $n $ est le troisième argument.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-180">It implements the single-qubit unitary $\exp(i \pi k \sigma / 2^n)$, where $\sigma$ is the Pauli matrix corresponding to the first argument, $k$ is the second argument, and $n$ is the third argument.</span></span>
<span data-ttu-id="4b8f4-181">`RFrac(_,k,n,_)` est le même que `R(_,-πk/2^n,_)` ; Notez que l’angle est la valeur *négative* de la fraction.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-181">`RFrac(_,k,n,_)` is the same as `R(_,-πk/2^n,_)`; note that the angle is the *negative* of the fraction.</span></span>

<span data-ttu-id="4b8f4-182">L' <xref:microsoft.quantum.intrinsic.rx> opération implémente une rotation autour de Pauli $X $ Axis.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-182">The <xref:microsoft.quantum.intrinsic.rx> operation implements a rotation around the Pauli $X$ axis.</span></span>
<span data-ttu-id="4b8f4-183">Il possède une signature `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-183">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-184">`Rx(_, _)` est identique à `R(PauliX, _, _)`.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-184">`Rx(_, _)` is the same as `R(PauliX, _, _)`.</span></span>

<span data-ttu-id="4b8f4-185">L' <xref:microsoft.quantum.intrinsic.ry> opération implémente une rotation autour de Pauli $Y $ Axis.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-185">The <xref:microsoft.quantum.intrinsic.ry> operation implements a rotation around the Pauli $Y$ axis.</span></span>
<span data-ttu-id="4b8f4-186">Il possède une signature `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-186">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-187">`Ry(_, _)` est identique à `R(PauliY,_ , _)`.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-187">`Ry(_, _)` is the same as `R(PauliY,_ , _)`.</span></span>

<span data-ttu-id="4b8f4-188">L' <xref:microsoft.quantum.intrinsic.rz> opération implémente une rotation autour de Pauli $Z $ AXIS.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-188">The <xref:microsoft.quantum.intrinsic.rz> operation implements a rotation around the Pauli $Z$ axis.</span></span>
<span data-ttu-id="4b8f4-189">Il possède une signature `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-189">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-190">`Rz(_, _)` est identique à `R(PauliZ, _, _)`.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-190">`Rz(_, _)` is the same as `R(PauliZ, _, _)`.</span></span>

<span data-ttu-id="4b8f4-191">L' <xref:microsoft.quantum.intrinsic.r1> opération implémente une rotation par le montant donné autour de $ \ket {1} $, le eigenstate $-$1 de $Z $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-191">The <xref:microsoft.quantum.intrinsic.r1> operation implements a rotation by the given amount around $\ket{1}$, the $-1$ eigenstate of $Z$.</span></span>
<span data-ttu-id="4b8f4-192">Il possède une signature `((Double, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-192">It has signature `((Double, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-193">`R1(phi,_)` est le même que celui `R(PauliZ,phi,_)` suivi par `R(PauliI,-phi,_)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-193">`R1(phi,_)` is the same as `R(PauliZ,phi,_)` followed by `R(PauliI,-phi,_)`.</span></span>

<span data-ttu-id="4b8f4-194">L' <xref:microsoft.quantum.intrinsic.r1frac> opération implémente une rotation fractionnaire en fonction de la valeur indiquée autour de Z = 1 eigenstate.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-194">The <xref:microsoft.quantum.intrinsic.r1frac> operation implements a fractional rotation by the given amount around the Z=1 eigenstate.</span></span>
<span data-ttu-id="4b8f4-195">Il possède une signature `((Int,Int, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-195">It has signature `((Int,Int, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-196">`R1Frac(k,n,_)` est le même que celui `RFrac(PauliZ,-k.n+1,_)` suivi par `RFrac(PauliI,k,n+1,_)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-196">`R1Frac(k,n,_)` is the same as `RFrac(PauliZ,-k.n+1,_)` followed by `RFrac(PauliI,k,n+1,_)`.</span></span>

<span data-ttu-id="4b8f4-197">Voici un exemple d’opération de rotation (autour du Pauli $Z $ AXIS, dans cette instance) mappée sur la sphère Bloch :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-197">An example of a rotation operation (around the Pauli $Z$ axis, in this instance) mapped onto the Bloch sphere is shown below:</span></span>

![Opération de rotation mappée sur la sphère Bloch](~/media/prelude_rotationBloch.png)

#### <a name="multi-qubit-operations"></a><span data-ttu-id="4b8f4-199">Opérations à plusieurs qubit</span><span class="sxs-lookup"><span data-stu-id="4b8f4-199">Multi-Qubit Operations</span></span> ####

<span data-ttu-id="4b8f4-200">En plus des opérations qubit ci-dessus, le préambule destiné à définit également plusieurs opérations à plusieurs qubit.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-200">In addition to the single-qubit operations above, the prelude also defines several multi-qubit operations.</span></span>

<span data-ttu-id="4b8f4-201">Tout d’abord, l' <xref:microsoft.quantum.intrinsic.cnot> opération effectue une porte contrôlée standard `NOT` , \begin{Equation} \operatorname{CNOT} \mathrel{ : =} \begin{bmatrix} 1 & 0 & 0 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \\ \\ 0 & 0 & 1 & 0 \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-201">First, the <xref:microsoft.quantum.intrinsic.cnot> operation performs a standard controlled-`NOT` gate, \begin{equation} \operatorname{CNOT} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \end{bmatrix}.</span></span>
<span data-ttu-id="4b8f4-202">\end{Equation} possède une signature `((Qubit, Qubit) => Unit is Adj + Ctl)` , représentant que $ \operatorname{CNOT} $ agit unitarily sur deux qubits individuels.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-202">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`, representing that $\operatorname{CNOT}$ acts unitarily on two individual qubits.</span></span>
<span data-ttu-id="4b8f4-203">`CNOT(q1, q2)` est identique à `(Controlled X)([q1], q2)`.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-203">`CNOT(q1, q2)` is the same as `(Controlled X)([q1], q2)`.</span></span>
<span data-ttu-id="4b8f4-204">Étant donné que le `Controlled` functor permet le contrôle sur un registre, nous utilisons le littéral `[q1]` de tableau pour indiquer que nous voulons uniquement le contrôle.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-204">Since the `Controlled` functor allows for controlling on a register, we use the array literal `[q1]` to indicate that we want only the one control.</span></span>

<span data-ttu-id="4b8f4-205">L' <xref:microsoft.quantum.intrinsic.ccnot> opération exécute une porte non contrôlée par doublement, parfois également appelée porte Toffoli.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-205">The <xref:microsoft.quantum.intrinsic.ccnot> operation performs doubly-controlled NOT gate, sometimes also known as the Toffoli gate.</span></span>
<span data-ttu-id="4b8f4-206">Il possède une signature `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-206">It has signature `((Qubit, Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-207">`CCNOT(q1, q2, q3)` est identique à `(Controlled X)([q1, q2], q3)`.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-207">`CCNOT(q1, q2, q3)` is the same as `(Controlled X)([q1, q2], q3)`.</span></span>

<span data-ttu-id="4b8f4-208">L' <xref:microsoft.quantum.intrinsic.swap> opération permute les États de quantum de deux qubits.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-208">The <xref:microsoft.quantum.intrinsic.swap> operation swaps the quantum states of two qubits.</span></span>
<span data-ttu-id="4b8f4-209">Autrement dit, il implémente la matrice \begin{Equation} \operatorname{SWAP} \mathrel{ : =} \begin{bmatrix} 1 & 0 & 0 & 0 \\ \\ 0 & 0 & 1 & 0 \\ \\ 0 & 1 & 0 & 0 \\ \\ 0 & 0 & 0 & 1 \end{bmatrix}.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-209">That is, it implements the unitary matrix \begin{equation} \operatorname{SWAP} \mathrel{:=} \begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \end{bmatrix}.</span></span>
<span data-ttu-id="4b8f4-210">\end{Equation} possède une signature `((Qubit, Qubit) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-210">\end{equation} It has signature `((Qubit, Qubit) => Unit is Adj + Ctl)`.</span></span>
<span data-ttu-id="4b8f4-211">`SWAP(q1,q2)` est équivalent à `CNOT(q1, q2)` suivi de `CNOT(q2, q1)` , puis `CNOT(q1, q2)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-211">`SWAP(q1,q2)` is equivalent to `CNOT(q1, q2)` followed by `CNOT(q2, q1)` and then `CNOT(q1, q2)`.</span></span>

> [!NOTE]
> <span data-ttu-id="4b8f4-212">La porte d’échange n’est *pas* la même que la réorganisation des éléments d’une variable de type `Qubit[]` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-212">The SWAP gate is *not* the same as rearranging the elements of a variable with type `Qubit[]`.</span></span>
> <span data-ttu-id="4b8f4-213">L’application `SWAP(q1, q2)` de entraîne une modification de l’état du qubits référencé par `q1` et `q2` , tout en `let swappedRegister = [q2, q1];` affectant uniquement la manière dont nous faisons référence à ces qubits.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-213">Applying `SWAP(q1, q2)` causes a change to the state of the qubits referred to by `q1` and `q2`, while `let swappedRegister = [q2, q1];` only affects how we refer to those qubits.</span></span>
> <span data-ttu-id="4b8f4-214">En outre, `(Controlled SWAP)([q0], (q1, q2))` permet `SWAP` à d’être conditionné sur l’état d’un troisième qubit, que nous ne pouvons pas représenter en réorganisant les éléments.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-214">Moreover, `(Controlled SWAP)([q0], (q1, q2))` allows for `SWAP` to be conditioned on the state of a third qubit, which we cannot represent by rearranging elements.</span></span>
> <span data-ttu-id="4b8f4-215">La porte contrôlée par échange, également appelée porte Fredkin, est suffisamment puissante pour inclure tous les calculs classiques.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-215">The controlled-SWAP gate, also known as the Fredkin gate, is powerful enough to include all classical computation.</span></span>

<span data-ttu-id="4b8f4-216">Enfin, le préambule destiné à fournit deux opérations pour représenter des exponentiels d’opérateurs Pauli à plusieurs qubit.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-216">Finally, the prelude provides two operations for representing exponentials of multi-qubit Pauli operators.</span></span>
<span data-ttu-id="4b8f4-217">L' <xref:microsoft.quantum.intrinsic.exp> opération effectue une rotation basée sur un produit tenseur de matrices Pauli, comme représenté par le qubit unitaire \Begin{Equation} \operatorname{exp} (\vec{\sigma}, \Phi) \mathrel{ : =} \exp\left (i \Phi \ sigma_0 \otimes \ sigma_1 \otimes \cdots \otimes \ sigma_n \right), \end{Equation} où $ \vec{\sigma} = (\ sigma_0, \ sigma_1, \dots, \ sigma_n) $ est une séquence d’opérateurs qubit Pauli, et où $ \Phi $ est un angle.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-217">The <xref:microsoft.quantum.intrinsic.exp> operation performs a rotation based on a tensor product of Pauli matrices, as represented by the multi-qubit unitary \begin{equation} \operatorname{Exp}(\vec{\sigma}, \phi) \mathrel{:=} \exp\left(i \phi \sigma_0 \otimes \sigma_1 \otimes \cdots \otimes \sigma_n \right), \end{equation} where $\vec{\sigma} = (\sigma_0, \sigma_1, \dots, \sigma_n)$ is a sequence of single-qubit Pauli operators, and where $\phi$ is an angle.</span></span>
<span data-ttu-id="4b8f4-218">La `Exp` rotation représente $ \vec{\sigma} $ sous la forme d’un tableau d' `Pauli` éléments, de sorte qu’elle possède une signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-218">The `Exp` rotation represents $\vec{\sigma}$ as an array of `Pauli` elements, such that it has signature `((Pauli[], Double, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

<span data-ttu-id="4b8f4-219">L' <xref:microsoft.quantum.intrinsic.expfrac> opération effectue la même rotation, à l’aide de la notation de fraction dyadic décrite ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-219">The <xref:microsoft.quantum.intrinsic.expfrac> operation performs the same rotation, using the dyadic fraction notation discussed above.</span></span>
<span data-ttu-id="4b8f4-220">Il possède une signature `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-220">It has signature `((Pauli[], Int, Int, Qubit[]) => Unit is Adj + Ctl)`.</span></span>

> [!WARNING]
> <span data-ttu-id="4b8f4-221">Les exponentiels du produit tenseur des opérateurs Pauli ne sont pas les mêmes que les produits tenseur des exponentiels des opérateurs Pauli.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-221">Exponentials of the tensor product of Pauli operators are not the same as tensor products of the exponentials of Pauli operators.</span></span>
> <span data-ttu-id="4b8f4-222">Autrement dit, $e ^ {i (Z \otimes Z) \Phi} \ne e ^ {i Z \Phi} \otimes e ^ {i Z \Phi} $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-222">That is, $e^{i (Z \otimes Z) \phi} \ne e^{i Z \phi} \otimes e^{i Z \phi}$.</span></span>

### <a name="measurements"></a><span data-ttu-id="4b8f4-223">Mesures</span><span class="sxs-lookup"><span data-stu-id="4b8f4-223">Measurements</span></span> ###

<span data-ttu-id="4b8f4-224">Lors de la mesure, le + 1 eigenvalue de l’opérateur mesuré correspond à un `Zero` résultat, et le-1 eigenvalue à un `One` résultat.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-224">When measuring, the +1 eigenvalue of the operator being measured corresponds to a `Zero` result, and the -1 eigenvalue to a `One` result.</span></span>

> [!NOTE]
> <span data-ttu-id="4b8f4-225">Bien que cette Convention puisse paraître étrange, elle présente deux avantages très intéressants.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-225">While this convention might seem odd, it has two very nice advantages.</span></span>
> <span data-ttu-id="4b8f4-226">Tout d’abord, l’observation du résultat $ \ket {0} $ est représentée par la `Result` valeur `Zero` , tandis que l’observation de $ \ket {1} $ correspond à `One` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-226">First, observing the outcome $\ket{0}$ is represented by the `Result` value `Zero`, while observing $\ket{1}$ corresponds to `One`.</span></span>
> <span data-ttu-id="4b8f4-227">Deuxièmement, nous pouvons écrire que le eigenvalue $ \lambda $ correspondant à un résultat $r $ est $ \lambda = (-1) ^ r $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-227">Second, we can write out that the eigenvalue $\lambda$ corresponding to a result $r$ is $\lambda = (-1)^r$.</span></span>

<span data-ttu-id="4b8f4-228">Les opérations de mesure ne prennent en charge ni le `Adjoint` functor ni le `Controlled` functor.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-228">Measurement operations support neither the `Adjoint` nor the `Controlled` functor.</span></span>

<span data-ttu-id="4b8f4-229">L' <xref:microsoft.quantum.intrinsic.measure> opération effectue une mesure conjointe d’un ou plusieurs qubits dans le produit spécifié des opérateurs Pauli.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-229">The <xref:microsoft.quantum.intrinsic.measure> operation performs a joint measurement of one or more qubits in the specified product of Pauli operators.</span></span>
<span data-ttu-id="4b8f4-230">Si le tableau Pauli et le tableau qubit ont des longueurs différentes, l’opération échoue.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-230">If the Pauli array and qubit array are different lengths, then the operation fails.</span></span>
<span data-ttu-id="4b8f4-231">`Measure` a une signature `((Pauli[], Qubit[]) => Result)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-231">`Measure` has signature `((Pauli[], Qubit[]) => Result)`.</span></span>

<span data-ttu-id="4b8f4-232">Notez qu’une mesure conjointe n’est pas identique à la mesure individuelle de chaque qubit.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-232">Note that a joint measurement is not the same as measuring each qubit individually.</span></span>
<span data-ttu-id="4b8f4-233">Par exemple, considérez l’État $ \ket {11} = \ket {1} \otimes \Ket {1} = X\otimes X \ket {00} $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-233">For example, consider the state $\ket{11} = \ket{1} \otimes \ket{1} = X\otimes X \ket{00}$.</span></span>
<span data-ttu-id="4b8f4-234">En mesurant $Z _0 $ et $Z _ 1 $ chaque individuellement, nous obtenons les résultats $r _0 = $1 et $r _ 1 = $1.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-234">Measuring $Z_0$ and $Z_1$ each individually, we get the results $r_0 = 1$ and $r_1 = 1$.</span></span>
<span data-ttu-id="4b8f4-235">En mesurant $Z _0 Z_1 $, nous obtenons le résultat unique $r _ {\textrm{joint}} = $0, ce qui indique que la paire de $ \ket {11} $ est positive.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-235">Measuring $Z_0 Z_1$, however, we get the single result $r_{\textrm{joint}} = 0$, representing that the pairity of $\ket{11}$ is positive.</span></span>
<span data-ttu-id="4b8f4-236">Put différemment, $ (-1) ^ {r_0 + r_1} = (-1) ^ r_ {\textrm{joint}}) $.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-236">Put differently, $(-1)^{r_0 + r_1} = (-1)^r_{\textrm{joint}})$.</span></span>
<span data-ttu-id="4b8f4-237">En effet, étant donné que nous ne prenons en compte *que* la parité de cette mesure, toutes les informations de Quantum représentées dans la superposition entre les États 2 2-qubit de parité positive, $ \ket {00} $ et $ \ket {11} $, sont conservées.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-237">Critically, since we *only* learn the parity from this measurement, any quantum information represented in the superposition between the two two-qubit states of positive parity, $\ket{00}$ and $\ket{11}$, is preserved.</span></span>
<span data-ttu-id="4b8f4-238">Cette propriété sera essentielle plus tard, car nous aborderons la correction des erreurs.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-238">This property will be essential later, as we discuss error correction.</span></span>

<span data-ttu-id="4b8f4-239">Pour plus de commodité, le préambule destiné à fournit également deux autres opérations pour mesurer qubits.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-239">For convenience, the prelude also provides two other operations for measuring qubits.</span></span>
<span data-ttu-id="4b8f4-240">Tout d’abord, étant donné que l’exécution de mesures qubit simples est assez courante, préambule destiné à définit un raccourci pour ce cas.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-240">First, since performing single-qubit measurements is quite common, the prelude defines a shorthand for this case.</span></span>
<span data-ttu-id="4b8f4-241">L' <xref:microsoft.quantum.intrinsic.m> opération mesure l’opérateur Pauli $Z $ sur un qubit unique et possède une signature `(Qubit => Result)` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-241">The <xref:microsoft.quantum.intrinsic.m> operation measures the Pauli $Z$ operator on a single qubit, and has signature `(Qubit => Result)`.</span></span>
<span data-ttu-id="4b8f4-242">`M(q)` équivaut à `Measure([PauliZ], [q])`.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-242">`M(q)` is equivalent to `Measure([PauliZ], [q])`.</span></span>

<span data-ttu-id="4b8f4-243">Le <xref:microsoft.quantum.measurement.multim> mesure le Pauli $Z $ Operator *séparément* sur chacun d’un tableau de qubits, en retournant le *tableau* de `Result` valeurs obtenues pour chaque qubit.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-243">The <xref:microsoft.quantum.measurement.multim> measures the Pauli $Z$ operator *separately* on each of an array of qubits, returning the *array* of `Result` values obtained for each qubit.</span></span>
<span data-ttu-id="4b8f4-244">Dans certains cas, cela peut être optimisé.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-244">In some cases this can be optimized.</span></span> <span data-ttu-id="4b8f4-245">Il possède une signature ( `Qubit[] => Result[])` .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-245">It has signature (`Qubit[] => Result[])`.</span></span>
<span data-ttu-id="4b8f4-246">`MultiM(qs)` équivaut à :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-246">`MultiM(qs)` is equivalent to:</span></span>

```qsharp
mutable rs = new Result[Length(qs)];
for (index in 0..Length(qs)-1)
{
    set rs[index] = M(qs[index]);
}
return rs;
```

## <a name="extension-functions-and-operations"></a><span data-ttu-id="4b8f4-247">Fonctions et opérations d’extension</span><span class="sxs-lookup"><span data-stu-id="4b8f4-247">Extension Functions and Operations</span></span> ##

<span data-ttu-id="4b8f4-248">En outre, préambule destiné à définit un ensemble complet de fonctions mathématiques et de conversion de type au niveau du .NET pour une utilisation dans le Q# code.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-248">In addition, the prelude defines a rich set of mathematical and type conversion functions at the .NET level for use within Q# code.</span></span>
<span data-ttu-id="4b8f4-249">Par exemple, l' <xref:microsoft.quantum.math> espace de noms définit des opérations utiles telles que <xref:microsoft.quantum.math.sin> et <xref:microsoft.quantum.math.log> .</span><span class="sxs-lookup"><span data-stu-id="4b8f4-249">For instance, the <xref:microsoft.quantum.math> namespace defines useful operations such as <xref:microsoft.quantum.math.sin> and <xref:microsoft.quantum.math.log>.</span></span>
<span data-ttu-id="4b8f4-250">L’implémentation fournie par le kit de développement quantum utilise la bibliothèque de classes de base .NET classique et peut donc impliquer un aller-retour supplémentaire entre les programmes Quantum et leurs pilotes classiques.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-250">The implementation provided by the Quantum Development Kit uses the classical .NET base class library, and thus may involve an additional communications round trip between quantum programs and their classical drivers.</span></span>
<span data-ttu-id="4b8f4-251">Bien que cela ne présente pas de problème pour un simulateur local, il peut s’agir d’un problème de performances lors de l’utilisation d’un simulateur distant ou d’un matériel réel comme ordinateur cible.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-251">While this does not present a problem for a local simulator, this can be a performance issue when using a remote simulator or actual hardware as a target machine.</span></span>
<span data-ttu-id="4b8f4-252">Cela dit, un ordinateur cible individuel peut atténuer cet impact sur les performances en remplaçant ces opérations par des versions qui sont plus efficaces pour ce système particulier.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-252">That said, an individual target machine may mitigate this performance impact by overriding these operations with versions that are more efficient for that particular system.</span></span>

### <a name="math"></a><span data-ttu-id="4b8f4-253">Math</span><span class="sxs-lookup"><span data-stu-id="4b8f4-253">Math</span></span> ###

<span data-ttu-id="4b8f4-254">L' <xref:microsoft.quantum.math> espace de noms fournit de nombreuses fonctions utiles à partir de la [ `System.Math` classe](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1)de la bibliothèque de classes de base .net.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-254">The <xref:microsoft.quantum.math> namespace provides many useful functions from the .NET base class library's [`System.Math` class](https://docs.microsoft.com/dotnet/api/system.math?view=netframework-4.7.1).</span></span>
<span data-ttu-id="4b8f4-255">Ces fonctions peuvent être utilisées de la même façon que toute autre Q# fonction :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-255">These functions can be used in the same manner as any other Q# functions:</span></span>

```qsharp
open Microsoft.Quantum.Math;
// ...
let y = Sin(theta);
```

<span data-ttu-id="4b8f4-256">Quand une méthode statique .NET a été surchargée en fonction du type de ses arguments, la Q# fonction correspondante est annotée avec un suffixe indiquant le type de son entrée :</span><span class="sxs-lookup"><span data-stu-id="4b8f4-256">Where a .NET static method has been overloaded based on the type of its arguments, the corresponding Q# function is annotated with a suffix indicating the type of its input:</span></span>

```qsharp
let x = AbsI(-3); // x : Int = 3
let y = AbsD(-PI()); // y : Double = 3.1415...
```


### <a name="bitwise-operations"></a><span data-ttu-id="4b8f4-257">Opérations au niveau du bit</span><span class="sxs-lookup"><span data-stu-id="4b8f4-257">Bitwise Operations</span></span> ###

<span data-ttu-id="4b8f4-258">Enfin, l' <xref:microsoft.quantum.bitwise> espace de noms fournit plusieurs fonctions utiles pour manipuler des entiers à l’aide d’opérateurs au niveau du bit.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-258">Finally, the <xref:microsoft.quantum.bitwise> namespace provides several useful functions for manipulating integers through bitwise operators.</span></span>
<span data-ttu-id="4b8f4-259">Par exemple, <xref:microsoft.quantum.bitwise.parity> retourne la parité au niveau du bit d’un entier sous la forme d’un autre entier.</span><span class="sxs-lookup"><span data-stu-id="4b8f4-259">For instance, <xref:microsoft.quantum.bitwise.parity> returns the bitwise parity of an integer as another integer.</span></span>
