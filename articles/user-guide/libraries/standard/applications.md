---
title: Applications dans les Q# bibliothèques standard
description: 'Découvrez deux applications fondamentales dans quantum computing : la simulation de la formation Hamilton et l’algorithme de recherche de Shori.'
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 4caacaad127f8a4d3b6f77efe35ebe7d3b97cacf
ms.sourcegitcommit: 6bf99d93590d6aa80490e88f2fd74dbbee8e0371
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 08/06/2020
ms.locfileid: "87868761"
---
# <a name="applications"></a><span data-ttu-id="31f5a-103">Applications</span><span class="sxs-lookup"><span data-stu-id="31f5a-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="31f5a-104">Simulation hamiltonienne</span><span class="sxs-lookup"><span data-stu-id="31f5a-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="31f5a-105">La simulation des systèmes quantiques est l’une des applications les plus passionnantes du calcul Quantum.</span><span class="sxs-lookup"><span data-stu-id="31f5a-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="31f5a-106">Sur un ordinateur classique, la difficulté de simuler le mécanisme quantique, en général, est mise à l’échelle avec la dimension $N $ de sa représentation de vecteur d’État.</span><span class="sxs-lookup"><span data-stu-id="31f5a-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="31f5a-107">Comme cette représentation s’agrandit de façon exponentielle avec le nombre de $n $ qubits $N = 2 ^ n $, une caractéristique connue également sous le nom [de « Curse of Dimensional](xref:microsoft.quantum.concepts.multiple-qubits)», la simulation de Quantum sur le matériel classique est inversée.</span><span class="sxs-lookup"><span data-stu-id="31f5a-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="31f5a-108">Toutefois, la situation peut être très différente sur le matériel Quantum.</span><span class="sxs-lookup"><span data-stu-id="31f5a-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="31f5a-109">La variation la plus courante de la simulation de Quantum est appelée problème de simulation de la durée de la simulation indépendante du temps.</span><span class="sxs-lookup"><span data-stu-id="31f5a-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="31f5a-110">À partir de là, une description du système Hamilton $H $, qui est une matrice Hermitian, et un État Quantum initial de $ \ket{\Psi (0)} $ qui est encodé sur $n $ qubits sur un ordinateur Quantum, sont fournies.</span><span class="sxs-lookup"><span data-stu-id="31f5a-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="31f5a-111">Comme les États quantiques dans les systèmes fermés évoluent sous l’équation Schrödinger $ $ \begin{align} i\frac {d \ket{\Psi (t)}} {d t} & = H \ket{\Psi (t)}, \end{align} $ $ l’objectif est d’implémenter l’opérateur d’évolution de l’heure unitaire $U (t) = e ^ {-iHt} $ à un moment fixe $t $, où $ \ket{\Psi (t)} = U (t) \ket{\Psi (0)} $ résout l’équation Schrödinger.</span><span class="sxs-lookup"><span data-stu-id="31f5a-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="31f5a-112">De même, le problème de simulation de la durée de la simulation, qui dépend du temps, résout la même équation, mais avec $H (t) $ Now.</span><span class="sxs-lookup"><span data-stu-id="31f5a-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="31f5a-113">La simulation de Hamilton est un composant majeur de nombreux autres problèmes de simulation de Quantum, tandis que les solutions à un problème de simulation de la haute---Hamilton sont des algorithmes qui décrivent une séquence de portes quantiques primitives permettant de synthétiser un \tilde{U} d’unités de $ \\ \\ dans la [norme spectrale](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="31f5a-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="31f5a-114">La complexité de ces algorithmes dépend fortement de la façon dont une description de l’intérêt de la personne en question est rendue accessible par un ordinateur quantique.</span><span class="sxs-lookup"><span data-stu-id="31f5a-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="31f5a-115">Par exemple, dans le pire des cas, si $H $ Status sur $n $ qubits devait être fourni sous la forme d’une liste de $2 ^ n \times 2 ^ n $ Numbers, un pour chaque élément de matrice, il suffit de lire les données pour qu’elles requièrent déjà un temps exponentiel.</span><span class="sxs-lookup"><span data-stu-id="31f5a-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="31f5a-116">Dans le meilleur des cas, il peut s’agir d’un accès à une unité de boîte noire qui $O \ket{t}\ket{\Psi (0)} = \ket{t}U (t) \ket{\Psi (0)} $ triflacon résout le problème.</span><span class="sxs-lookup"><span data-stu-id="31f5a-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="31f5a-117">Aucun de ces modèles d’entrée n’est particulièrement intéressant : le premier, car il n’est pas mieux que les approches classiques, et ce dernier comme la boîte noire masque la complexité de la porte primitive de son implémentation, qui pourrait être exponentielle dans le nombre de qubits.</span><span class="sxs-lookup"><span data-stu-id="31f5a-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="31f5a-118">Descriptions des Hamiltonians</span><span class="sxs-lookup"><span data-stu-id="31f5a-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="31f5a-119">Des hypothèses supplémentaires concernant le format de l’entrée sont donc requises.</span><span class="sxs-lookup"><span data-stu-id="31f5a-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="31f5a-120">Une balance fine doit être comprise entre les modèles d’entrée qui sont suffisamment descriptifs pour englober des Hamiltonians intéressants, tels que ceux pour les systèmes physiques réalistes ou les problèmes de calcul intéressants, et les modèles d’entrée suffisamment restrictifs pour pouvoir être implémentés efficacement sur un ordinateur quantique.</span><span class="sxs-lookup"><span data-stu-id="31f5a-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="31f5a-121">Un large éventail de modèles d’entrée non triviales peut être trouvé dans la documentation et il est compris entre Quantum et classique.</span><span class="sxs-lookup"><span data-stu-id="31f5a-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="31f5a-122">En guise d’exemples de modèles d’entrée quantique, la [simulation de type Hamilton basé sur les échantillons](http://www.nature.com/articles/s41534-017-0013-7) suppose un accès à la boîte noire aux opérations quantiques qui produisent des copies d’une matrice de densité $ \rho $, qui sont considérées comme étant de type Hamilton $H $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="31f5a-123">Dans le [modèle d’accès](https://arxiv.org/abs/1202.5822) à l’unité, on suppose que le lieu de la Hamilton se décompose en une somme de l’unité $ $ \begin{align} H & = \sum ^ {d-1} \_ {j = 0} a \_ j \hat{U} \_ j, \end{align} $ $ où $a \_ j>$0 sont coefficients et $ \hat{U} \_ j $ sont des unités.</span><span class="sxs-lookup"><span data-stu-id="31f5a-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="31f5a-124">Il est ensuite supposé que l’un d’entre eux a accès à la boîte noire à l' $V Oracle d’unités = \sum ^ {d-1} \_ {j = 0} \Ket{j}\bra{j}\otimes \hat{U} \_ j $ qui sélectionne le $ \hat{U} \_ j $ souhaité. et Oracle $A \ket {0} = \sum ^ {d-1} \_ {j = 0} \sqrt{a \_ j/\ Sum ^ {d-1} \_ {k = 0} \alpha \_ j} \ket{j} $ qui créent un État Quantum codant ces coefficients.</span><span class="sxs-lookup"><span data-stu-id="31f5a-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="31f5a-125">Dans le cas d’une simulation de la mise à niveau de la base de la [Hamilton](https://arxiv.org/abs/quant-ph/0301023), on suppose que la matrice Hamilton est une matrice éparse avec uniquement $d = \mathcal{O} (\text{polylog} (N)) $ élément non nul dans chaque ligne.</span><span class="sxs-lookup"><span data-stu-id="31f5a-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="31f5a-126">En outre, il suppose l’existence de circuits quantiques efficaces qui génèrent l’emplacement de ces éléments non nuls, ainsi que leurs valeurs.</span><span class="sxs-lookup"><span data-stu-id="31f5a-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="31f5a-127">La complexité des [algorithmes de simulation](xref:microsoft.quantum.more-information) de la plus grande taille est évaluée en termes de nombre de requêtes à ces cases noires, et la complexité de la porte primitive dépend alors beaucoup de la difficulté à mettre en œuvre ces cases noires.</span><span class="sxs-lookup"><span data-stu-id="31f5a-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="31f5a-128">La notation Big-O est couramment utilisée pour décrire la complexité de la mise à l’échelle des algorithmes.</span><span class="sxs-lookup"><span data-stu-id="31f5a-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="31f5a-129">À partir de deux fonctions réelles $f, g $, l’expression $g (x) = \mathcal{O} (f (x)) $ signifie qu’il existe une constante positive absolue $x \_ 0, c>$0 de sorte que $g (x) \Le c (x) $ pour tous les $x \ge x \_ $0.</span><span class="sxs-lookup"><span data-stu-id="31f5a-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="31f5a-130">Dans la plupart des applications pratiques à implémenter sur un ordinateur Quantum, ces cases noires doivent être implémentées de manière efficace, c’est-à-dire avec les portes Quantum de $ \mathcal{O} (\text{polylog} (N)) $ Primitives.</span><span class="sxs-lookup"><span data-stu-id="31f5a-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="31f5a-131">Un Hamiltonians simulable plus efficace doit avoir une description classique suffisamment éparpillée.</span><span class="sxs-lookup"><span data-stu-id="31f5a-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="31f5a-132">Dans l’une de ces formulations, il est supposé que le sous-type de la Hermitian est décomposé en une somme des parties de la $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="31f5a-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="31f5a-133">\end{align} $ $ en outre, il est supposé que chaque partie, un $H de la même-et de \_ j $, est facile à simuler.</span><span class="sxs-lookup"><span data-stu-id="31f5a-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="31f5a-134">Cela signifie que le $e unitaire ^ {-1 \_ j t} $ pour chaque fois $t $ peut être implémenté exactement à l’aide de $ \mathcal{O} (1) $ portes quantiques de la primitive.</span><span class="sxs-lookup"><span data-stu-id="31f5a-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="31f5a-135">C’est le cas, par exemple, dans le cas particulier où chaque $H \_ j $ est un Pauli local, ce qui signifie qu’il s’agit de produits tenseur des opérateurs de $ \mathcal{O} (1) $ non-Identity Pauli qui agissent sur la fermeture spatiale qubits.</span><span class="sxs-lookup"><span data-stu-id="31f5a-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="31f5a-136">Ce modèle est particulièrement applicable aux systèmes physiques avec une interaction limitée et locale, car le nombre de termes est $d = \mathcal{O} (\text{polylog} (N)) $ et peut être clairement écrit, par exemple, décrit de façon classique, en temps polynomial.</span><span class="sxs-lookup"><span data-stu-id="31f5a-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="31f5a-137">Les Hamiltonians qui se décomposent en une somme des parties peuvent être décrites à l’aide de la bibliothèque de représentation du générateur dynamique.</span><span class="sxs-lookup"><span data-stu-id="31f5a-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="31f5a-138">Pour plus d’informations, consultez la section relative à la représentation du générateur dynamique dans [structures de données](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="31f5a-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="31f5a-139">Algorithmes de simulation</span><span class="sxs-lookup"><span data-stu-id="31f5a-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="31f5a-140">Un algorithme de simulation de Quantum convertit une description donnée d’un sous-sein en une séquence de portes quantiques primitives qui, dans l’ensemble, est une évolution approximative de la durée de ce même point de la même manière.</span><span class="sxs-lookup"><span data-stu-id="31f5a-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="31f5a-141">Dans le cas particulier où la décomposition de la partie Hamilton se décompose en une somme de Hermitian, la décomposition Trotter-Suzuki est un algorithme particulièrement simple et intuitif pour simuler les Hamiltonians qui se décomposent en une somme des composants Hermitian.</span><span class="sxs-lookup"><span data-stu-id="31f5a-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="31f5a-142">Par exemple, un intégrateur de première ordre de cette famille est proche de $ $ \begin{align} U (t) & = \left (e ^ {--- \_ 1 0 t/r} e ^ {-1 à 1 t/r} \_ \cdots e ^ {--m \_ {d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j \\ | H \_ j \\ | ^ 2 t ^ 2/r), \end{align} $ $ utilisant un produit de $r d $ terms.</span><span class="sxs-lookup"><span data-stu-id="31f5a-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="31f5a-143">Les applications de l’algorithme de simulation Trotter-Suzuki sont abordées dans les exemples.</span><span class="sxs-lookup"><span data-stu-id="31f5a-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="31f5a-144">Pour le modèle Ising utilisant uniquement les opérations intrinsèques fournies par chaque ordinateur cible, consultez l' [exemple **SimpleIsing** ](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="31f5a-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="31f5a-145">Pour le modèle Ising à l’aide de la structure de contrôle de la bibliothèque Trotter-Suzuki, consultez l' [exemple **IsingTrotter** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="31f5a-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="31f5a-146">Pour l’hydrogène moléculaire à l’aide de la structure de contrôle de la bibliothèque Trotter-Suzuki, consultez l’exemple de [ **simulation H2** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="31f5a-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="31f5a-147">Dans de nombreux cas, nous aimerions implémenter l’algorithme de simulation, mais ils ne sont pas intéressés par les détails de son implémentation.</span><span class="sxs-lookup"><span data-stu-id="31f5a-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="31f5a-148">Par exemple, l’intégrateur de deuxième ordre se rapproche de $ $ \begin{align} U (t) & = \left (e ^ {-- \_ 1 0 t/2R} e ^ {-1 à 1 t/2R \_ } \cdots e ^ {---u \_ {d-1} t/2R} e ^ {- \_ \cdots {d-1} t/2R} e ^ {- \_ 1-1 t/2R} e ^ {--1 \_ 0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j \\ | H \_ j \\ | ^ 3 t ^ 3/r ^ 2), \end{align} $ $ utilisant un produit de $2rd $ terms.</span><span class="sxs-lookup"><span data-stu-id="31f5a-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="31f5a-149">Les commandes plus volumineuses impliquent encore plus de termes et les variantes optimisées peuvent nécessiter des commandes très simples sur les exponentiels.</span><span class="sxs-lookup"><span data-stu-id="31f5a-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="31f5a-150">D’autres algorithmes avancés peuvent également impliquer l’utilisation de Ancilla qubits dans les étapes intermédiaires.</span><span class="sxs-lookup"><span data-stu-id="31f5a-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="31f5a-151">Nous allons donc empaqueter des algorithmes de simulation dans Canon comme type défini par l’utilisateur</span><span class="sxs-lookup"><span data-stu-id="31f5a-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="31f5a-152">Le premier paramètre `Double` est l’heure de la simulation, le deuxième paramètre `EvolutionGenerator` , couvert dans la section relative à la représentation du générateur dynamique des [structures de données](xref:microsoft.quantum.libraries.data-structures), est une description classique d’un lieu de Hamilton indépendant du temps, avec des instructions sur la façon dont chaque terme dans le lieu de la zone Hamilton peut être simulé par un circuit quantique.</span><span class="sxs-lookup"><span data-stu-id="31f5a-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="31f5a-153">Les types de ce formulaire se rapprochent de l’opération unitaire $e ^ {-iHt} $ sur le troisième paramètre `Qubit[]` , qui est le Registre qui stocke l’État Quantum du système simulé.</span><span class="sxs-lookup"><span data-stu-id="31f5a-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="31f5a-154">De même, pour le cas dépendant du temps, nous définissons un type défini par l’utilisateur avec un type à la `EvolutionSchedule` place, qui est une description classique d’un lieu de type Hamilton dépendant du temps.</span><span class="sxs-lookup"><span data-stu-id="31f5a-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="31f5a-155">Par exemple, la décomposition Trotter-Suzuki peut être appelée à l’aide des fonctions Canon suivantes, avec des paramètres `trotterStepSize` modifiant la durée de la simulation dans chaque exponentiel et `trotterOrder` pour l’ordre de l’intégrateur souhaité.</span><span class="sxs-lookup"><span data-stu-id="31f5a-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="31f5a-156">Les applications de la bibliothèque de simulation sont abordées dans les exemples.</span><span class="sxs-lookup"><span data-stu-id="31f5a-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="31f5a-157">Pour l’estimation de phase dans le modèle Ising à l’aide de `SimulationAlgorithm` , consultez l' [exemple **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="31f5a-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="31f5a-158">Pour la préparation de l’État adiabatic dans le modèle Ising à l’aide de `TimeDependentSimulationAlgorithm` , consultez l' [exemple **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="31f5a-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="31f5a-159">Estimation de la phase de préparation de l’État adiabatic &</span><span class="sxs-lookup"><span data-stu-id="31f5a-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="31f5a-160">Une application courante de la simulation de la Hamilton est la préparation de l’État adiabatic.</span><span class="sxs-lookup"><span data-stu-id="31f5a-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="31f5a-161">Ici, un est fourni avec deux Hamiltonians $H \_ {\text{Start}} $ et $H \_ {\text{end}} $, et un État Quantum $ \ket{\Psi (0)} $ qui est un État du sol de la $H start Hamilton \_ {\text{Start}} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="31f5a-162">En général, $H \_ {\text{Start}} $ est choisi, de sorte que $ \ket{\Psi (0)} $ est facile à préparer à partir d’un état de base de calcul $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="31f5a-163">En interpolent suffisamment lentement entre ces Hamiltonians dans le problème de simulation dépendant du temps, il est possible de se retrouver, avec une probabilité élevée, dans un État du sol de la version de la version finale de la région de la $H \_ {\text{end}} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="31f5a-164">Bien qu’il soit possible de préparer de bonnes approximations aux États de la terre de Hamilton, en appelant sur les algorithmes de simulation de la simulation d’une sous-routine en tant que sous-routine, d’autres approches conceptuelles différentes, telles que les eigensolver quantiques variantes, sont possibles.</span><span class="sxs-lookup"><span data-stu-id="31f5a-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="31f5a-165">Une autre application omniprésente en chimie Quantum consiste à estimer l’énergie de l’état du sol des Hamiltonians représentant les étapes intermédiaires de la réaction chimique.</span><span class="sxs-lookup"><span data-stu-id="31f5a-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="31f5a-166">Ce type de schéma pourrait, par exemple, s’appuyer sur la préparation de l’état de adiabatic pour créer l’état du sol, puis incorporer la simulation de la phase de production indépendante du temps en tant que sous-routine dans la caractérisation de l’estimation de la phase pour extraire cette énergie avec une erreur finie et une probabilité de réussite.</span><span class="sxs-lookup"><span data-stu-id="31f5a-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="31f5a-167">Abstraction des algorithmes de simulation en tant que types définis par l’utilisateur `SimulationAlgorithm` et `TimeDependentSimulationAlgorithm` nous permettre d’intégrer facilement leurs fonctionnalités dans des algorithmes Quantum plus sophistiqués.</span><span class="sxs-lookup"><span data-stu-id="31f5a-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="31f5a-168">Cela nous incite à faire de même pour ces sous-routines couramment utilisées.</span><span class="sxs-lookup"><span data-stu-id="31f5a-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="31f5a-169">Nous définissons donc la fonction pratique</span><span class="sxs-lookup"><span data-stu-id="31f5a-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="31f5a-170">Cela retourne une opération unitaire qui implémente toutes les étapes de préparation de l’État adiabatic.</span><span class="sxs-lookup"><span data-stu-id="31f5a-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="31f5a-171">Le premier paramètre `interpolatedTime` définit la durée pendant laquelle nous interpolent de façon linéaire entre le début de la Hamilton, décrit par le deuxième paramètre `evolutionGeneratorStart` et l’end Hamilton décrit par le troisième paramètre `evolutionGeneratorEnd` .</span><span class="sxs-lookup"><span data-stu-id="31f5a-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="31f5a-172">Le quatrième paramètre `timeDependentSimulationAlgorithm` est l’endroit où un algorithme de simulation est choisi.</span><span class="sxs-lookup"><span data-stu-id="31f5a-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="31f5a-173">Notez que si `interpolatedTime` est suffisamment long, un état initial de la terre reste un état de terre instantané de la région de la même manière sur toute la durée de la simulation dépendante du temps, et se termine donc à l’état du sol de la fin de la Hamilton.</span><span class="sxs-lookup"><span data-stu-id="31f5a-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="31f5a-174">Nous définissons également une opération utile qui effectue automatiquement toutes les étapes d’une expérience de type chimie Quantum typique.</span><span class="sxs-lookup"><span data-stu-id="31f5a-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="31f5a-175">Par exemple, nous avons les éléments suivants, qui retournent une estimation d’énergie de l’État produit par la préparation de l’État adiabatic :</span><span class="sxs-lookup"><span data-stu-id="31f5a-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="31f5a-176">`nQubits`nombre de qubits utilisés pour encoder l’État Quantum initial.</span><span class="sxs-lookup"><span data-stu-id="31f5a-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="31f5a-177">`statePrepUnitary`prépare l’état de démarrage à partir de la base de calcul $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="31f5a-178">`adiabaticUnitary`est l’opération unitaire qui implémente la préparation de l’État adiabatic, telle que produite par la `InterpolatedEvolution` fonction.</span><span class="sxs-lookup"><span data-stu-id="31f5a-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="31f5a-179">`qpeUnitary`est l’opération unitaire qui est utilisée pour effectuer une estimation de phase sur l’État Quantum résultant.</span><span class="sxs-lookup"><span data-stu-id="31f5a-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="31f5a-180">`phaseEstAlgorithm`est notre choix d’algorithme d’estimation de phase.</span><span class="sxs-lookup"><span data-stu-id="31f5a-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="31f5a-181">Les applications de préparation de l’État adiabatic sont traitées dans les exemples.</span><span class="sxs-lookup"><span data-stu-id="31f5a-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="31f5a-182">Pour le modèle Ising utilisant une implémentation manuelle de la préparation de l’état de adiabatic et l’utilisation de la `AdiabaticEvolution` fonction, consultez l' [exemple **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="31f5a-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="31f5a-183">Pour l’estimation de phase et la préparation de l’État adiabatic dans le modèle Ising, consultez l' [exemple **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="31f5a-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="31f5a-184">La [simulation de l’hydrogène moléculaire](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) est un exemple intéressant et bref.</span><span class="sxs-lookup"><span data-stu-id="31f5a-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="31f5a-185">Le modèle et les résultats expérimentaux ont été signalés dans [O’Malley et. al.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="31f5a-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="31f5a-186">nécessite uniquement des matrices Pauli et prend la forme $ \hat H = g \_ {0} I \_ 0i \_ 1 + g \_ 1 {z \_ 0} + g \_ 2 {Z \_ 1} + g \_ 3 {z 0 \_ } {z \_ 1} + g \_ 4 {y \_ 0} {y 1} \_ + g \_ 5 {x \_ 0} {x \_ 1} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="31f5a-187">Il s’agit d’un lieu de Hamilton efficace qui ne requiert que 2 qubits, où les constantes $g $ sont calculées à partir de la distance $R $ entre les deux atomes d’hydrogène.</span><span class="sxs-lookup"><span data-stu-id="31f5a-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="31f5a-188">À l’aide des fonctions Canon, les Paulis sont convertis en unités, puis évoluées sur de courtes périodes à l’aide de la décomposition Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="31f5a-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="31f5a-189">Une bonne approximation de l’état du sol $H _2 $ peut être créée sans utiliser la préparation de l’état de la adiabatic, et l’énergie de l’état du sol peut donc être trouvée directement en utilisant l’estimation de phase de l’Canon.</span><span class="sxs-lookup"><span data-stu-id="31f5a-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="31f5a-190">Algorithme de Shor</span><span class="sxs-lookup"><span data-stu-id="31f5a-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="31f5a-191">L’algorithme de Shori reste l’un des développements les plus significatifs de l’informatique Quantum, car il a montré que les ordinateurs quantiques pouvaient être utilisés pour résoudre des problèmes importants, actuellement des problèmes d’inversion classiques.</span><span class="sxs-lookup"><span data-stu-id="31f5a-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="31f5a-192">L’algorithme de Shori offre un moyen rapide de factoriser de grands nombres à l’aide d’un ordinateur quantique, un problème appelé *factorisation*.</span><span class="sxs-lookup"><span data-stu-id="31f5a-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="31f5a-193">La sécurité de nombreux Cryptosystems en cours d’existence est basée sur l’hypothèse qu’il n’existe aucun algorithme rapide pour la factorisation.</span><span class="sxs-lookup"><span data-stu-id="31f5a-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="31f5a-194">Ainsi, l’algorithme de Shori a eu un impact important sur la façon dont nous pensons à la sécurité dans un monde postérieur au quantum.</span><span class="sxs-lookup"><span data-stu-id="31f5a-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="31f5a-195">L’algorithme de Shori peut être considéré comme un algorithme hybride.</span><span class="sxs-lookup"><span data-stu-id="31f5a-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="31f5a-196">L’ordinateur Quantum est utilisé pour effectuer une tâche matérielle de calcul connue sous le nom de période de recherche.</span><span class="sxs-lookup"><span data-stu-id="31f5a-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="31f5a-197">Les résultats de la recherche de période sont ensuite traités de façon classique pour estimer les facteurs.</span><span class="sxs-lookup"><span data-stu-id="31f5a-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="31f5a-198">Nous allons passer en revue ces deux étapes ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="31f5a-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="31f5a-199">Recherche de période</span><span class="sxs-lookup"><span data-stu-id="31f5a-199">Period Finding</span></span> ###

<span data-ttu-id="31f5a-200">Après avoir vu comment le fonctionnement de la transformation de Fourier quantique et l’estimation de phase (voir [algorithmes Quantum](xref:microsoft.quantum.libraries.standard.algorithms)), nous pouvons utiliser ces outils pour résoudre un problème de calcul classique appelé *période de recherche*.</span><span class="sxs-lookup"><span data-stu-id="31f5a-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="31f5a-201">Dans la section suivante, nous verrons comment appliquer la détection de période à la factorisation.</span><span class="sxs-lookup"><span data-stu-id="31f5a-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="31f5a-202">À partir de deux entiers $a $ et $N $, où $a<N $, l’objectif de la recherche de la période, également appelée recherche de commande, est de trouver la _commande_ $r $ de $a $ modulo $N $, où $r $ est défini comme étant le moins positif $a ^ r \equiv 1 \text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="31f5a-203">Pour trouver la commande à l’aide d’un ordinateur Quantum, nous pouvons utiliser l’algorithme d’estimation de la phase appliqué à l’opérateur d’unités suivant $U _a $ : $ $ U_a \ket{x} \equiv \ket{(ax) \text{mod} N}. $ $ vecteurs propres de $U _a $ sont des nombres entiers $s $ et $0 \ Leq s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum \_ {k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \ket{a ^ k\text {mod} N}, $ $ sont _eigenstates_ de $U _A $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="31f5a-204">Le valeurs propres de $U _a $ est $ $ U \_ a \ket{x \_ s} = e ^ {2 \ pi i s/r} \ket{x \_ s}.</span><span class="sxs-lookup"><span data-stu-id="31f5a-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="31f5a-205">L’estimation de la phase génère donc la valeurs propres $e ^ {2 \ pi i s/r} $ à partir de laquelle $r $ peut être appris efficacement à l’aide de [fractions continues](https://en.wikipedia.org/wiki/Continued_fraction) de $s/r $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="31f5a-206">Le schéma de circuit pour la période Quantum Finding est le suivant :</span><span class="sxs-lookup"><span data-stu-id="31f5a-206">The circuit diagram for quantum period finding is:</span></span>

![Diagramme de circuit pour la recherche d’une période de Quantum](~/media/QPE.svg)

<span data-ttu-id="31f5a-208">Ici, $2n $ qubits est initialisé à $ \ket {0} $ et $n $ qubits sont initialisés à $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-208">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="31f5a-209">À nouveau, le lecteur peut se demander pourquoi le registre quantique contenant le eigenstates est initialisé à $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-209">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="31f5a-210">Comme il ne sait pas que l’ordre $r $ à l’avance, nous ne pouvons pas préparer les États $ \ket{x_s} $ directement.</span><span class="sxs-lookup"><span data-stu-id="31f5a-210">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="31f5a-211">Heureusement, il s’avère que $1/\ sqrt {r} \sum \_ {s = 0} ^ {r-1} \ket{x \_ s} = \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-211">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="31f5a-212">Nous n’avons pas besoin de préparer réellement $ \ket{x} $ !</span><span class="sxs-lookup"><span data-stu-id="31f5a-212">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="31f5a-213">Nous pouvons simplement préparer un registre quantique de $n $ qubits dans l’État $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-213">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="31f5a-214">Le circuit contient les QFT et plusieurs portes contrôlées.</span><span class="sxs-lookup"><span data-stu-id="31f5a-214">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="31f5a-215">La porte QFT a été décrite [précédemment](xref:microsoft.quantum.libraries.standard.algorithms).</span><span class="sxs-lookup"><span data-stu-id="31f5a-215">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="31f5a-216">Le $U contrôlé _a $ Gate mappe $ \ket{x} $ à $ \ket{(ax) \text{mod} N} $ si le contrôle qubit est $ \ket {1} $, et mappe $ \ket{x} $ à $ \ket{x} $ dans le cas contraire.</span><span class="sxs-lookup"><span data-stu-id="31f5a-216">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="31f5a-217">Pour obtenir $ (a ^ NX) \text{mod} N $, nous pouvons simplement appliquer le contrôle de $U _ {a ^ n} $, où nous calculons $a ^ n \text{mod} N $ de façon classique pour brancher le circuit Quantum.</span><span class="sxs-lookup"><span data-stu-id="31f5a-217">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="31f5a-218">Les circuits permettant d’atteindre ce type d’arithmétique modulaire ont été décrits dans la documentation sur les opérations [arithmétiques Quantum](./algorithms.md#arithmetic), en particulier, nous avons besoin d’un circuit modulaire à élévation à la puissance pour implémenter les opérations de $U de contrôle \_ {a ^ i} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-218">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="31f5a-219">Alors que le circuit ci-dessus correspond à l' [estimation de phase quantique](xref:microsoft.quantum.characterization.quantumphaseestimation) et active explicitement la recherche de commande, nous pouvons réduire le nombre de qubits requis.</span><span class="sxs-lookup"><span data-stu-id="31f5a-219">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="31f5a-220">Nous pouvons soit suivre la méthode de Beauregard pour trouver la commande comme décrit [à la page 8 de arXiv : quant-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), soit utiliser l’une des routines d’estimation de phase disponibles dans Microsoft. Quantum. caractérisation.</span><span class="sxs-lookup"><span data-stu-id="31f5a-220">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="31f5a-221">Par exemple, l' [estimation de phase robuste](xref:microsoft.quantum.characterization.robustphaseestimation) utilise également un qubit supplémentaire.</span><span class="sxs-lookup"><span data-stu-id="31f5a-221">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="31f5a-222">Factorisation</span><span class="sxs-lookup"><span data-stu-id="31f5a-222">Factoring</span></span> ###
<span data-ttu-id="31f5a-223">L’objectif de la factorisation est de déterminer les deux facteurs premiers de l’entier $N $, où $N $ est un nombre $n de $ bits.</span><span class="sxs-lookup"><span data-stu-id="31f5a-223">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="31f5a-224">La factorisation se compose des étapes décrites ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="31f5a-224">Factoring consists of the steps described below.</span></span> <span data-ttu-id="31f5a-225">Les étapes sont divisées en trois parties : une routine de prétraitement classique (1-4); une routine quantum computing pour trouver l’ordre de $a \text{mod} N $ (5); et une routine de post-traitement classique pour dériver les facteurs premiers de la commande (6-9).</span><span class="sxs-lookup"><span data-stu-id="31f5a-225">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="31f5a-226">La routine de prétraitement classique comprend les étapes suivantes :</span><span class="sxs-lookup"><span data-stu-id="31f5a-226">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="31f5a-227">Si $N $ est pair, retournez le facteur premier $2 $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-227">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="31f5a-228">Si $N = p ^ q $ pour $p \geq1 $, $q \geq2 $, retourne le facteur principal $p $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-228">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="31f5a-229">Cette étape est effectuée de façon classique.</span><span class="sxs-lookup"><span data-stu-id="31f5a-229">This step is performed classically.</span></span>
3. <span data-ttu-id="31f5a-230">Choisissez un nombre aléatoire $a $ de sorte que $1 < a < N-$1.</span><span class="sxs-lookup"><span data-stu-id="31f5a-230">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="31f5a-231">Si $ \text{GCD} (a, N) >$1, retourner le facteur de prime $ \text{GCD} (a, N) $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-231">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="31f5a-232">Cette étape est calculée à l’aide de l’algorithme de Euclide permettant.</span><span class="sxs-lookup"><span data-stu-id="31f5a-232">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="31f5a-233">Si aucun facteur principal n’a été retourné, nous procédons à la routine Quantum :</span><span class="sxs-lookup"><span data-stu-id="31f5a-233">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="31f5a-234">Appelez l’algorithme de recherche de période de Quantum pour calculer la commande $r $ sur $a \text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-234">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="31f5a-235">Utilisez $r $ dans la routine de post-traitement classique pour déterminer les facteurs premiers :</span><span class="sxs-lookup"><span data-stu-id="31f5a-235">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="31f5a-236">Si $r $ est impair, revenez à l’étape de prétraitement (3).</span><span class="sxs-lookup"><span data-stu-id="31f5a-236">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="31f5a-237">Si $r $ est pair et $a ^ {r/2} =-1 \ Text {mod} N $, revenez à l’étape de prétraitement (3).</span><span class="sxs-lookup"><span data-stu-id="31f5a-237">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="31f5a-238">Si $ \text{GCD} (a ^ {r/2} + 1, N) $ est un facteur non négligeable de $N $, retournez $ \text{GCD} (a ^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-238">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="31f5a-239">Si $ \text{GCD} (a ^ {r/2}-1, N) $ est un facteur non négligeable de $N $, retournez $ \text{GCD} (a ^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-239">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="31f5a-240">L’algorithme de factorisation est probabiliste : il peut être démontré qu’avec une probabilité d’au moins une demi-$r $ sera même et $a ^ {r/2} \neq-1 \text{mod} N $, produisant ainsi un facteur premier.</span><span class="sxs-lookup"><span data-stu-id="31f5a-240">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="31f5a-241">(Pour plus d’informations, consultez le [document original de Shori](https://doi.org/10.1109/SFCS.1994.365700) ou l’un des textes de *base de quantum computing* dans [pour plus d’informations](xref:microsoft.quantum.more-information)).</span><span class="sxs-lookup"><span data-stu-id="31f5a-241">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="31f5a-242">Si un facteur principal n’est pas retourné, il suffit de répéter l’algorithme à partir de l’étape (1).</span><span class="sxs-lookup"><span data-stu-id="31f5a-242">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="31f5a-243">Une fois que $n $ tentatives, la probabilité que chaque tentative ait échoué est au maximum de $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="31f5a-243">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="31f5a-244">Ainsi, après la répétition de l’algorithme, un petit nombre de fois où la réussite est pratiquement assurée.</span><span class="sxs-lookup"><span data-stu-id="31f5a-244">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
