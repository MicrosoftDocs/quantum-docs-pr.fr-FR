---
title: Caractérisation quantique et statistiques
description: Découvrez comment les statistiques de mesure des estimations de phase sont utilisées pour estimer les valeurs de résultats dans la programmation quantique.
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- Q#
- $$v
ms.openlocfilehash: 72af3f5517b272d6d8159b158103b5af91d266b5
ms.sourcegitcommit: c48cdafccb3487bf93d67fa80cdc64768445b691
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 01/06/2021
ms.locfileid: "97940884"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="78a0f-103">Caractérisation quantique et statistiques</span><span class="sxs-lookup"><span data-stu-id="78a0f-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="78a0f-104">Il est essentiel de pouvoir caractériser les effets des opérations afin de développer des algorithmes Quantum utiles.</span><span class="sxs-lookup"><span data-stu-id="78a0f-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="78a0f-105">Cela est difficile, car chaque mesure d’un système Quantum produit au plus un peu d’informations.</span><span class="sxs-lookup"><span data-stu-id="78a0f-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="78a0f-106">Pour apprendre un eigenvalue, laisser un État Quantum autonome, les résultats de nombreuses mesures doivent être regroupés afin que l’utilisateur puisse glaner les nombreux éléments d’informations nécessaires pour représenter ces concepts.</span><span class="sxs-lookup"><span data-stu-id="78a0f-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="78a0f-107">Les États quantiques sont particulièrement vexing, car le titre de [non-clonage](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) stipule qu’il n’existe aucun moyen d’apprendre un État Quantum arbitraire à partir d’une copie unique de l’État, car cela vous permet de créer des copies de l’État.</span><span class="sxs-lookup"><span data-stu-id="78a0f-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="78a0f-108">Cet obscurcissement de l’État Quantum de l’utilisateur est reflété dans le fait que Q# n’expose pas ou ne définit pas l’état  des programmes quantiques.</span><span class="sxs-lookup"><span data-stu-id="78a0f-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="78a0f-109">Nous allons donc aborder la caractérisation quantique en traitant les opérations et les États comme une boîte noire. Cette approche partage en grande partie en commun avec la pratique expérimentale de la caractérisation quantique, la vérification et la validation (QCVV).</span><span class="sxs-lookup"><span data-stu-id="78a0f-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="78a0f-110">La caractérisation est distincte de la plupart des autres bibliothèques présentées précédemment.</span><span class="sxs-lookup"><span data-stu-id="78a0f-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="78a0f-111">L’objectif ici est de réduire les informations classiques sur le système, plutôt que d’effectuer une transformation unitaire sur un vecteur d’État.</span><span class="sxs-lookup"><span data-stu-id="78a0f-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="78a0f-112">Ces bibliothèques doivent donc fusionner à la fois le traitement des informations de Quantum et le traitement des informations.</span><span class="sxs-lookup"><span data-stu-id="78a0f-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="78a0f-113">Estimation de la phase itérative</span><span class="sxs-lookup"><span data-stu-id="78a0f-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="78a0f-114">L’affichage de la programmation quantique en termes de caractérisation quantique suggère une alternative utile à l’estimation de la phase Quantum.</span><span class="sxs-lookup"><span data-stu-id="78a0f-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="78a0f-115">Autrement dit, au lieu de préparer un registre $n $-qubit pour contenir une représentation binaire de la phase comme dans l’estimation de la phase Quantum, nous pouvons voir l’estimation de la phase comme processus par lequel un agent *classique* apprend les propriétés d’un système Quantum par le biais de mesures.</span><span class="sxs-lookup"><span data-stu-id="78a0f-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="78a0f-116">Nous procédons comme dans le cas Quantum en utilisant la phase Kickback pour transformer les applications d’une opération de boîte noire en rotations d’un angle inconnu, mais mesurer le qubit Ancilla que nous allons faire pivoter à chaque étape immédiatement après la rotation.</span><span class="sxs-lookup"><span data-stu-id="78a0f-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="78a0f-117">Cela présente l’avantage que nous n’avons besoin que d’un seul qubit supplémentaire pour effectuer la phase Kickback décrite dans le cas Quantum, car nous apprenons ensuite la phase des résultats de mesure à chaque étape de manière itérative.</span><span class="sxs-lookup"><span data-stu-id="78a0f-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="78a0f-118">Chacune des méthodes proposées ci-dessous utilise une stratégie différente pour concevoir des expériences et différentes méthodes de traitement des données pour apprendre la phase.</span><span class="sxs-lookup"><span data-stu-id="78a0f-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="78a0f-119">Ils ont chacun un avantage unique, allant de l’utilisation de limites d’erreurs rigoureuses, aux capacités d’incorporation d’informations antérieures, de tolérer des erreurs ou de s’exécuter sur des ordinateurs classiques limitteds de la mémoire.</span><span class="sxs-lookup"><span data-stu-id="78a0f-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="78a0f-120">Dans le cadre de l’estimation itérative de la phase, nous allons considérer un $U unitaire $ donné comme une opération de boîte noire.</span><span class="sxs-lookup"><span data-stu-id="78a0f-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="78a0f-121">Comme décrit dans la section sur oracles dans les [structures de données](xref:microsoft.quantum.libraries.data-structures), Q# Canon modélise ces opérations par le <xref:Microsoft.Quantum.Oracles.DiscreteOracle> type défini par l’utilisateur, défini par le type de Tuple `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="78a0f-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="78a0f-122">Concrètement, si `U : DiscreteOracle` , `U(m)` implémente $U ^ m $ pour `m : Int` .</span><span class="sxs-lookup"><span data-stu-id="78a0f-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="78a0f-123">Une fois cette définition en place, chaque étape de l’estimation de phase itérative se poursuit en préparant un qubit auxiliaire dans l’État $ \ket{+} $ avec l’état initial $ \ket{\Phi} $ dont nous supposons qu’il s’agit d’un [extraction](xref:microsoft.quantum.concepts.matrix-advanced) de $U (m) $, par exemple $U (m) \ket{\Phi} = e ^ {im\phi} \ Ket {\ Phi} $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="78a0f-124">Une application contrôlée de `U(m)` est ensuite utilisée pour préparer l’État $ \left (R \_ 1 (m \Phi) \ket{+} \right) \ket{\Phi} $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="78a0f-125">Comme dans le cas Quantum, l’effet d’une application contrôlée d’Oracle `U(m)` est exactement le même que l’application de $R _ 1 $ pour la phase inconnue sur $ \ket{+} $, de sorte que nous pouvons décrire les effets de $U $ dans cette méthode plus simple.</span><span class="sxs-lookup"><span data-stu-id="78a0f-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="78a0f-126">Si vous le souhaitez, l’algorithme fait pivoter le contrôle qubit en appliquant $R _ 1 (-m\theta) $ pour obtenir un État $ \ket{\Psi} = \left (R \_ 1 (m [\Phi-\Theta]) \ket{+} \right) \ket{\Phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="78a0f-127">Le qubit auxiliaire utilisé comme contrôle pour `U(m)` est ensuite mesuré dans le $X $ pour obtenir un seul classique `Result` .</span><span class="sxs-lookup"><span data-stu-id="78a0f-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="78a0f-128">À ce stade, la reconstruction de la phase à partir des `Result` valeurs obtenues par le biais d’une estimation de phase itérative est un problème d’inférence statistique classique.</span><span class="sxs-lookup"><span data-stu-id="78a0f-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="78a0f-129">La recherche de la valeur de $m $ qui maximise les informations obtenues, en fonction d’une méthode d’inférence fixe, est simplement un problème dans les statistiques.</span><span class="sxs-lookup"><span data-stu-id="78a0f-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="78a0f-130">Nous insistons sur cela en décrivant brièvement l’estimation de phase itérative à un niveau théorique dans le formalisme d’estimation du paramètre bayésien avant de continuer à décrire les algorithmes statistiques fournis dans Q# Canon pour résoudre ce problème d’inférence classique.</span><span class="sxs-lookup"><span data-stu-id="78a0f-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="78a0f-131">Estimation itérative de la phase sans Eigenstates</span><span class="sxs-lookup"><span data-stu-id="78a0f-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="78a0f-132">Si un état d’entrée qui n’est pas un eigenstate est fourni, ce qui signifie que si $U (m) \ket{\Phi \_ j} = e ^ {im\phi \_ j} $, le processus d’estimation de phase ne redirige pas de façon déterminante l’État Quantum vers un eigenstate d’énergie unique.</span><span class="sxs-lookup"><span data-stu-id="78a0f-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="78a0f-133">Le eigenstate qui se converge finalement vers est le eigenstate qui est le plus susceptible de produire le observé `Result` .</span><span class="sxs-lookup"><span data-stu-id="78a0f-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="78a0f-134">Plus précisément, une seule étape de PE effectue la transformation non unitaire suivante sur un État \begin{align} \ sum_j \sqrt{\Pr (\Phi \_ j)} \ket{\Phi \_ j} \mapsto \sum \_ j\frac {\ sqrt {\ PR (\Phi \_ j)} \sqrt{\Pr (\text{result} | \Phi \_ j)} \Ket{\Phi \_ j}} {\sqrt{\Pr (\Phi \_ j) \sum \_ k \Pr (\text{result} | \Phi \_ k)}}.</span><span class="sxs-lookup"><span data-stu-id="78a0f-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_k \Pr(\text{Result}|\phi\_k)}}.</span></span>
<span data-ttu-id="78a0f-135">\end{align} étant donné que ce processus est itéré sur plusieurs `Result` valeurs, les eigenstates qui n’ont pas de valeurs maximales de $ \ prod_k \pr (\text{result} \_ k | \Phi \_ j) $ seront supprimés de façon exponentielle.</span><span class="sxs-lookup"><span data-stu-id="78a0f-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="78a0f-136">Par conséquent, le processus d’inférence aura tendance à converger vers des États avec un seul eigenvalue si les expériences sont correctement choisies.</span><span class="sxs-lookup"><span data-stu-id="78a0f-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="78a0f-137">Bayes’le type d’enregistrement suggère également que l’état résultant de l’estimation de la phase soit écrit sous la forme \begin{align} \frac{\sqrt{\Pr (\Phi \_ j)} \sqrt{\Pr (\text{result} | \Phi \_ j)} \ket{\Phi \_ j}} {\sqrt{\Pr (\Phi \_ j) \Sum \_ j \Pr (\text{result} | \Phi \_ j)}} = \ sum_j \sqrt{\Pr (\Phi \_ j | \text{result})} \ket{\Phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="78a0f-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="78a0f-138">\end{align} ici $ \Pr (\Phi \_ j | \text{result}) $ peut être interprété comme la probabilité qu’un ASCRIBE à chaque hypothèse sur le eigenstates donné :</span><span class="sxs-lookup"><span data-stu-id="78a0f-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="78a0f-139">connaissance de l’État Quantum avant la mesure,</span><span class="sxs-lookup"><span data-stu-id="78a0f-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="78a0f-140">connaissance du eigenstates de $U $ et,</span><span class="sxs-lookup"><span data-stu-id="78a0f-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="78a0f-141">connaissance du valeurs propres de $U $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="78a0f-142">L’apprentissage de ces trois éléments est souvent très difficile sur un ordinateur classique.</span><span class="sxs-lookup"><span data-stu-id="78a0f-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="78a0f-143">L’utilitaire de l’estimation de la phase se présente, à peu de temps, du fait qu’il peut exécuter une telle tâche d’apprentissage quantique sans en connaître aucune.</span><span class="sxs-lookup"><span data-stu-id="78a0f-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="78a0f-144">L’estimation de la phase pour cette raison s’affiche dans un certain nombre d’algorithmes Quantum qui fournissent des accélérations exponentielles.</span><span class="sxs-lookup"><span data-stu-id="78a0f-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="78a0f-145">Estimation de la phase bayésienne</span><span class="sxs-lookup"><span data-stu-id="78a0f-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="78a0f-146">Pour plus d’informations sur l’estimation de la phase bayésien dans la pratique, consultez l’exemple [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) .</span><span class="sxs-lookup"><span data-stu-id="78a0f-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="78a0f-147">L’estimation de la phase bayésienne est simple.</span><span class="sxs-lookup"><span data-stu-id="78a0f-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="78a0f-148">Vous recueillez des statistiques de mesure à partir du protocole d’estimation de phase, puis vous traitez les résultats à l’aide de l’inférence Bayésienne et fournissez une estimation du paramètre.</span><span class="sxs-lookup"><span data-stu-id="78a0f-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="78a0f-149">Ce traitement vous donne une estimation des eigenvalue, ainsi que de l’incertitude dans cette estimation.</span><span class="sxs-lookup"><span data-stu-id="78a0f-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="78a0f-150">Elle vous permet également d’effectuer des expérimentations adaptatives et d’utiliser des informations antérieures.</span><span class="sxs-lookup"><span data-stu-id="78a0f-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="78a0f-151">L’inconvénient des méthodes est qu’elle exige des calculs.</span><span class="sxs-lookup"><span data-stu-id="78a0f-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="78a0f-152">Pour comprendre le fonctionnement de ce processus d’inférence Bayésienne, prenez le cas de traiter un `Zero` résultat unique.</span><span class="sxs-lookup"><span data-stu-id="78a0f-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="78a0f-153">Notez que $X = \ket{+} \bra{+}-\ket {-} \bra {-} $, de sorte que $ \ket{+} $ est le seul eigenstate positif de $X $ correspondant à `Zero` .</span><span class="sxs-lookup"><span data-stu-id="78a0f-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="78a0f-154">La probabilité d’observer `Zero` une [ `PauliX` mesure](xref:microsoft.quantum.concepts.pauli) sur le premier qubit en fonction de l’état d’entrée $ \ket{\Psi}\ket{\Phi} $ est donc \begin{Equation} \Pr (\texttt{Zero} | \Psi) = \left | \braket{+ | \Psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="78a0f-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="78a0f-155">\end{Equation} dans le cas de l’estimation itérative de la phase, nous avons \ket{\Psi} = R_1 (m [\Phi-\Theta]) \ket{+} $, de telle sorte que \begin{align} \Pr (\texttt{Zero} | \Phi ; m, \Theta) & = \left | \braket{+ | R_1 (m [\Phi-\Theta]) | +} \right | ^ 2 \\ \\ & = \left | \frac12 \left (\bra {0} + \bra {1} \right) \left (\ket {0} + e ^ {i m [\Phi-\Theta]} \ket {1} \right) \right | ^ 2 \\ \\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}} {2} \right | ^ 2 \\ \\ & = \cos ^ 2 (m [\Phi-\Theta]/2) \tag{★} \label{EQ : phase-est-vraisemblance}.</span><span class="sxs-lookup"><span data-stu-id="78a0f-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="78a0f-156">\end{align} qui est, l’estimation de la phase itérative consiste à apprendre la fréquence d’oscillation d’une fonction sinusoïdale, étant donné la capacité de retourner une pièce de monnaie avec un décalage donné par ce sinusoïdal.</span><span class="sxs-lookup"><span data-stu-id="78a0f-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="78a0f-157">À la suite de la terminologie classique traditionnelle, nous appelons $ \eqref{EQ : phase-est-vraisemblance} $ la *fonction de probabilité* pour l’estimation de la phase itérative.</span><span class="sxs-lookup"><span data-stu-id="78a0f-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="78a0f-158">Après avoir observé un `Result` à partir de la fonction de probabilité d’estimation de la phase itérative, nous pouvons ensuite utiliser la règle de Bayes pour prescrire ce que nous devrions estimer la phase à suivre.</span><span class="sxs-lookup"><span data-stu-id="78a0f-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="78a0f-159">Concrètement, \begin{Equation} \Pr (\Phi | d) = \frac{\Pr (d | \Phi) \Pr (\Phi)} {\int \Pr (d | \Phi) \Pr (\Phi) {\mathrm d} \Phi} \Pr (\Phi), \end{Equation} où $d \Dans \\ {\texttt{Zero}, \texttt{One} \\ } $ est un `Result` , et où $ \Pr (\Phi) $ décrit nos opinions antérieures sur $ \Phi $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="78a0f-160">Cela rend ensuite la nature itérative de l’estimation de phase itérative explicite, car la distribution POSTERIEURE $ \Pr (\Phi | d) $ décrit nos points de présence qui précèdent immédiatement l’observation de la suivante `Result` .</span><span class="sxs-lookup"><span data-stu-id="78a0f-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="78a0f-161">À tout moment pendant cette procédure, nous pouvons signaler la phase $ \hat{\Phi} $ déduite par le contrôleur classique en tant que \begin{Equation} \hat{\Phi} \mathrel{ : =} \expect [\Phi | \text{Data}] = \int \Phi \Pr (\Phi | \text{Data}) {\mathrm d} \Phi, \end{Equation} où $ \text{Data} $ correspond à l’enregistrement complet de toutes les `Result` valeurs obtenues.</span><span class="sxs-lookup"><span data-stu-id="78a0f-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="78a0f-162">L’inférence Bayésienne exacte est dans la pratique inversement.</span><span class="sxs-lookup"><span data-stu-id="78a0f-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="78a0f-163">Pour voir cela, imaginez que nous souhaitons apprendre une variable de $n $-bit $x $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="78a0f-164">La distribution antérieure $ \Pr (x) $ prend en charge plus de $2 ^ n $ valeurs hypothétiques de $x $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="78a0f-165">Cela signifie que si nous avons besoin d’une estimation très précise de $x $, l’estimation de la phase Bayésiene peut nécessiter une mémoire et un temps de traitement prohibitifs.</span><span class="sxs-lookup"><span data-stu-id="78a0f-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="78a0f-166">Bien que pour certaines applications, telles que la simulation de Quantum, la précision limitted requise n’exclut pas ces méthodes, d’autres applications, telles que l’algorithme de Shori, ne peuvent pas utiliser l’inférence Bayésienne exacte au cours de l’étape d’estimation de la phase.</span><span class="sxs-lookup"><span data-stu-id="78a0f-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="78a0f-167">Pour cette raison, nous fournissons également des implémentations pour des méthodes Bayésienles approximatives telles que l' [estimation de phase de parcours aléatoire (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) et également des approches non bayésienles telles que l' [estimation de phase fiable](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span><span class="sxs-lookup"><span data-stu-id="78a0f-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="78a0f-168">Estimation de phase robuste</span><span class="sxs-lookup"><span data-stu-id="78a0f-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="78a0f-169">*Une reconstruction bayésienne* au maximum d’une estimation de phase à partir des résultats de mesure est de façon exponentielle dans le pire des cas.</span><span class="sxs-lookup"><span data-stu-id="78a0f-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="78a0f-170">Ainsi, la plupart des algorithmes d’estimation de la phase pratique sacrifient une certaine qualité de la reconstruction, en échange d’une quantité de traitement classique qui, à la place, s’adapte au degré polynomial avec le nombre de mesures effectuées.</span><span class="sxs-lookup"><span data-stu-id="78a0f-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="78a0f-171">L' [algorithme d’estimation de phase robuste](https://arxiv.org/abs/1502.02677), avec sa signature et ses entrées mentionnées ci-dessus, est un exemple avec une étape de traitement classique efficace.</span><span class="sxs-lookup"><span data-stu-id="78a0f-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="78a0f-172">Il part du principe que les boîtiers noirs d’entrée $U $ sont empaquetés en tant que `DiscreteOracle` type et, par conséquent, interroge uniquement les valeurs entières de Control-$U $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="78a0f-173">Si l’état d’entrée dans le `Qubit[]` Registre est un eigenstate $U \ket{\Psi} = e ^ {i\phi} \ Ket {\ psi} $, l’algorithme d’estimation de phase robuste retourne une estimation $ \hat{\Phi}\in [-\pi, \pi) $ de $ \Phi $ en tant que `Double` .</span><span class="sxs-lookup"><span data-stu-id="78a0f-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="78a0f-174">La fonctionnalité la plus importante de l’estimation de phase fiable, qui est partagée avec la plupart des autres variantes utiles, est que la qualité de reconstruction de $ \hat{\Phi} $ est dans un sens Heisenberg-Limited.</span><span class="sxs-lookup"><span data-stu-id="78a0f-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="78a0f-175">Cela signifie que si l’écart de $ \hat{\Phi} $ de la valeur true est $ \sigma $, alors $ \sigma $ est mis à l’échelle inversement-proportionnel au nombre total de requêtes $Q $ effectuées à Control-$U $, c’est-à-dire $ \sigma = \mathcal{O} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="78a0f-176">À présent, la définition de l’écart varie selon les différents algorithmes d’estimation.</span><span class="sxs-lookup"><span data-stu-id="78a0f-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="78a0f-177">Dans certains cas, cela peut signifier qu’avec au moins $ \mathcal{O} (1) $ probabilité, l’erreur d’estimation $ | \hat{\Phi}-\Phi | \_ \circ\le \sigma $ sur une mesure circulaire $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="78a0f-178">Pour une estimation de phase robuste, l’écart est précisément l’écart $ \sigma ^ 2 = \mathbb{E} \_ \hat{\Phi} [(\mod \_ {2 \ pi} (\hat{\Phi}-\Phi + \pi)-\pi) ^ 2] $ si nous désencapsulons les phases périodiques sur un seul intervalle fini $ (-\pi, \pi] $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="78a0f-179">Plus précisément, l’écart type de l’estimation de phase fiable satisfait aux inégales $ $ \begin{align} 2,0 \pi/Q \Le \sigma \Le 2 \ pi/2 ^ {n} \Le 10.7 \ pi/Q, \end{align} $ $ où la limite inférieure est atteinte dans la limite de asymptotiquement grande $Q $, et la limite supérieure est garantie même pour les petites tailles d’échantillonnage.</span><span class="sxs-lookup"><span data-stu-id="78a0f-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="78a0f-180">Notez que $n $ sélectionné par l' `bitsPrecision` entrée, qui définit implicitement $Q $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="78a0f-181">D’autres informations pertinentes incluent, par exemple, la surcharge de petite taille de seulement $1 $ Ancilla qubit, ou la procédure n’est pas adaptative, ce qui signifie que la séquence requise des expérimentations de Quantum est indépendante des résultats de mesure intermédiaires.</span><span class="sxs-lookup"><span data-stu-id="78a0f-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="78a0f-182">Dans cet exemple et les prochains exemples où le choix de l’algorithme d’estimation de la phase est important, il est préférable de faire référence à la documentation telle que @"microsoft.quantum.characterization.robustphaseestimation" et les publications référencées dans ce document pour obtenir plus d’informations et pour leur implémentation.</span><span class="sxs-lookup"><span data-stu-id="78a0f-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="78a0f-183">Il existe de nombreux exemples dans lesquels l’estimation de phase robuste est utilisée.</span><span class="sxs-lookup"><span data-stu-id="78a0f-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="78a0f-184">Pour l’estimation de phase dans l’extraction de l’énergie d’État du sol de divers systèmes physiques, consultez l’exemple de [ **simulation H2**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), l' [exemple **SimpleIsing**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)et l’exemple de [ **modèle Hubbard**](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="78a0f-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="78a0f-185">Oracle continue</span><span class="sxs-lookup"><span data-stu-id="78a0f-185">Continuous Oracles</span></span> ###

<span data-ttu-id="78a0f-186">Nous pouvons également généraliser à partir du modèle Oracle utilisé ci-dessus pour autoriser les Oracle à temps continu, modélisés par le type Canon <xref:Microsoft.Quantum.Oracles.ContinuousOracle> .</span><span class="sxs-lookup"><span data-stu-id="78a0f-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="78a0f-187">Supposons qu’au lieu d’un opérateur d’unité unique $U $, nous disposons d’une famille d’opérateurs unitaires $U (t) $ pour $t \Dans \mathbb{R} $, ce qui $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="78a0f-188">Il s’agit d’une instruction plus faible que dans le cas discret, puisque nous pouvons construire un <xref:Microsoft.Quantum.Oracles.DiscreteOracle> en restreignant $t = m \, \delta t $ pour un $ \delta t $ fixe.</span><span class="sxs-lookup"><span data-stu-id="78a0f-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="78a0f-189">Par le [fabricant de pierres](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i H t) $ pour un opérateur $H $, où $ \exp $ est la matrice exponentielle comme décrit dans [matrices avancées](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="78a0f-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="78a0f-190">Un eigenstate $ \ket{\Phi} $ de $H $ comme $H \ket{\Phi} = \Phi \ket{\Phi} $ est également une eigenstate de $U (t) $ pour tous les $t $, \begin{Equation} U (t) \ket{\Phi} = e ^ {\Phi t} \ket{\Phi}.</span><span class="sxs-lookup"><span data-stu-id="78a0f-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="78a0f-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="78a0f-191">\end{equation}</span></span>

<span data-ttu-id="78a0f-192">Exactement la même analyse abordée pour l’estimation de la [phase bayésienne](#bayesian-phase-estimation) peut être appliquée, et la fonction de vraisemblance est exactement la même pour ce modèle Oracle plus général : $ $ \Pr (\texttt{Zero} | \Phi ; t, \Theta) = \cos ^ 2 \ Left (\frac{t [\Phi-\Theta]} {2} \right).</span><span class="sxs-lookup"><span data-stu-id="78a0f-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="78a0f-193">$ $ En outre, si $U $ est une simulation d’un générateur dynamique, comme c’est le cas pour la [simulation de Hamilton](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), nous interprétons $ \Phi $ comme une énergie.</span><span class="sxs-lookup"><span data-stu-id="78a0f-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="78a0f-194">Par conséquent, l’utilisation de la fonction d’estimation de phase avec des requêtes continues nous permet d’apprendre le [spectre énergétique simulé des molécules, des](https://arxiv.org/abs/quant-ph/0604193) [matériaux](https://arxiv.org/abs/1510.03859) ou des théories sur les [champs](https://arxiv.org/abs/1111.3633v2) sans avoir à compromettre notre choix d’expériences en exigeant $t $ comme un entier.</span><span class="sxs-lookup"><span data-stu-id="78a0f-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="78a0f-195">Estimation de la phase de parcours aléatoire</span><span class="sxs-lookup"><span data-stu-id="78a0f-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="78a0f-196">Q# fournit une approximation utile de l’estimation de la phase bayésien conçue pour une utilisation proche des appareils quantiques qui fonctionnent en conditionné un parcours aléatoire sur l’enregistrement de données obtenu à partir d’une estimation de la phase itérative.</span><span class="sxs-lookup"><span data-stu-id="78a0f-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="78a0f-197">Cette méthode est à la fois adaptative et entièrement déterministe, ce qui permet une mise à l’échelle presque optimale des erreurs dans la phase estimée $ \hat{\Phi} $ avec des surcharges de mémoire très faibles.</span><span class="sxs-lookup"><span data-stu-id="78a0f-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="78a0f-198">Le protocole utilise une méthode d’inférence Bayésienle approximative qui suppose que la distribution antérieure est gaussienne.</span><span class="sxs-lookup"><span data-stu-id="78a0f-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="78a0f-199">Cette hypothèse gaussienne nous permet d’utiliser une formule analytique pour l’expérience qui minimise la variance postérieure.</span><span class="sxs-lookup"><span data-stu-id="78a0f-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="78a0f-200">L’algorithme ensuite, en fonction du résultat de cette expérience, déplace l’estimation de $ \Phi $ Left ou Right d’une quantité prédéterminée et réduit la variance d’une quantité prédéterminée.</span><span class="sxs-lookup"><span data-stu-id="78a0f-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="78a0f-201">Cette moyenne et cette variance fournissent toutes les informations nécessaires pour spécifier une valeur gaussienne antérieure à $ \Phi $ pour l’expérience suivante.</span><span class="sxs-lookup"><span data-stu-id="78a0f-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="78a0f-202">Des échecs de mesure inattendus ou le résultat réel sur les queues de l’initiale précédente peuvent entraîner l’échec de cette méthode.</span><span class="sxs-lookup"><span data-stu-id="78a0f-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="78a0f-203">Il récupère de la défaillance en effectuant des expérimentations pour tester si la moyenne actuelle et l’écart type sont appropriés pour le système.</span><span class="sxs-lookup"><span data-stu-id="78a0f-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="78a0f-204">Si ce n’est pas le cas, l’algorithme effectue une étape inverse du parcours et le processus continue.</span><span class="sxs-lookup"><span data-stu-id="78a0f-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="78a0f-205">La possibilité de revenir en arrière permet également à l’algorithme d’apprendre même si l’écart type initial antérieur est inapropriately petit.</span><span class="sxs-lookup"><span data-stu-id="78a0f-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="78a0f-206">Appel d’algorithmes d’estimation de phase</span><span class="sxs-lookup"><span data-stu-id="78a0f-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="78a0f-207">Chaque opération d’estimation de phase fournie avec Q# Canon prend un ensemble différent d’entrées paramétrant la qualité que nous demandons de l’estimation finale $ \hat{\Phi} $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="78a0f-208">Ces différentes entrées, cependant, partagent toutes plusieurs entrées en commun, de telle sorte que l’application partielle sur les paramètres de qualité entraîne une signature commune.</span><span class="sxs-lookup"><span data-stu-id="78a0f-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="78a0f-209">Par exemple, l' <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> opération décrite dans la section suivante a la signature suivante :</span><span class="sxs-lookup"><span data-stu-id="78a0f-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="78a0f-210">L' `bitsPrecision` entrée est unique à `RobustPhaseEstimation` , tandis que `oracle` et `eigenstate` sont en commun.</span><span class="sxs-lookup"><span data-stu-id="78a0f-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="78a0f-211">Ainsi, comme indiqué dans **H2Sample**, une opération peut accepter un algorithme d’estimation de phase itérative avec une entrée de la forme `(DiscreteOracle, Qubit[]) => Unit` pour permettre à un utilisateur de spécifier des algorithmes d’estimation de phase arbitraires :</span><span class="sxs-lookup"><span data-stu-id="78a0f-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="78a0f-212">Ces algorithmes d’estimation de myriade de phases sont optimisés pour différentes propriétés et paramètres d’entrée, qui doivent être compris pour faire le meilleur choix pour l’application cible.</span><span class="sxs-lookup"><span data-stu-id="78a0f-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="78a0f-213">Par exemple, certains algorithmes d’estimation de phase sont adaptatifs, ce qui signifie que les étapes futures sont contrôlées de manière classique par les résultats de mesure des étapes précédentes.</span><span class="sxs-lookup"><span data-stu-id="78a0f-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="78a0f-214">Certains requièrent la capacité d’exponentiate de son Oracle sous la boîte noire par des pouvoirs réels arbitraires, tandis que d’autres ne nécessitent que des valeurs entières, mais sont uniquement en mesure de résoudre une estimation de phase modulo $2 \ pi $.</span><span class="sxs-lookup"><span data-stu-id="78a0f-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="78a0f-215">Certains requièrent un grand nombre d’qubits auxiliaires, tandis que d’autres en ont besoin.</span><span class="sxs-lookup"><span data-stu-id="78a0f-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="78a0f-216">De même, l’estimation de la phase de parcours aléatoire s’effectue de la même façon que pour les autres algorithmes fournis avec Canon :</span><span class="sxs-lookup"><span data-stu-id="78a0f-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
