---
title: 'Algorithmes Quantum dans :::no-loc(Q#):::'
description: Découvrez les algorithmes de quantum computing fondamentaux, y compris l’amplification d’amplitude, les transformations de Fourier, les ajouts de Draper et de Beauregard et l’estimation de phase.
author: QuantumWriter
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 982103876b00718aa3b42c6bc3a07d242cde7594
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692226"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="9512e-103">Algorithmes Quantum</span><span class="sxs-lookup"><span data-stu-id="9512e-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="9512e-104">Amplification d’amplitude</span><span class="sxs-lookup"><span data-stu-id="9512e-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="9512e-105">L' *amplification d’amplitude* est l’un des outils fondamentaux de quantum computing.</span><span class="sxs-lookup"><span data-stu-id="9512e-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="9512e-106">Il s’agit de l’idée fondamentale qui repose sur la recherche de Grover, l’estimation de l’amplitude et de nombreux algorithmes Quantum Machine Learning.</span><span class="sxs-lookup"><span data-stu-id="9512e-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="9512e-107">Il existe de nombreuses variantes et, dans, :::no-loc(Q#)::: nous fournissons une version générale basée sur l’amplification de l’amplitude oublie avec des réflexions partielles pour permettre le plus grand éventail d’applications.</span><span class="sxs-lookup"><span data-stu-id="9512e-107">There are many variants, and in :::no-loc(Q#)::: we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="9512e-108">L’idée centrale derrière l’amplification d’amplitude consiste à amplifier la probabilité qu’un résultat escompté se produise en effectuant une séquence de réflexions.</span><span class="sxs-lookup"><span data-stu-id="9512e-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="9512e-109">Ces réflexions font pivoter l’état initial vers un État cible souhaité, souvent appelé état marqué.</span><span class="sxs-lookup"><span data-stu-id="9512e-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="9512e-110">Plus précisément, si la probabilité de la mesure de l’état initial dans un État marqué est $ \sin ^ 2 (\Theta) $, après l’application de l’amplification d’amplitude $m $ fois la probabilité de réussite devient $ \sin ^ 2 ((2m + 1) \Theta) $.</span><span class="sxs-lookup"><span data-stu-id="9512e-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="9512e-111">Cela signifie que si $ \Theta = \ pi/[2 (2n + 1)] $ pour une valeur de $n $ Then amplification d’amplitude est capable d’augmenter la probabilité de succès à $100 \\ % $ après $n $ itérations d’amplification d’amplitude.</span><span class="sxs-lookup"><span data-stu-id="9512e-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="9512e-112">Depuis $ \Theta = \sin ^ {-1} (\sqrt{\Pr (Success)}) $, cela signifie que le nombre d’itérations nécessaires pour obtenir un succès déterministe est augmentera inférieur au nombre attendu requis pour trouver un État marqué non déterministe à l’aide d’un échantillonnage aléatoire.</span><span class="sxs-lookup"><span data-stu-id="9512e-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="9512e-113">Chaque itération de l’amplification d’amplitude requiert la spécification de deux opérateurs de réflexion.</span><span class="sxs-lookup"><span data-stu-id="9512e-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="9512e-114">Plus précisément, si $Q $ est l’itération d’amplification d’amplitude et $P _0 $ est un opérateur de projecteur dans le sous-espace initial et $P 1 _ 1 est le projecteur sur le sous-espace marqué, $Q =-(\boldone-2P_0) (\boldone-2P_1) $.</span><span class="sxs-lookup"><span data-stu-id="9512e-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="9512e-115">Rappelez-vous qu’un projecteur est un opérateur Hermitian dont les valeurs propres $ + $1 et $0 $ et, par conséquent, $ (\boldone-2P_0) $ est unitaire parce qu’il comporte des valeurs propres racines d’Unity (dans ce cas, $ \pm $1).</span><span class="sxs-lookup"><span data-stu-id="9512e-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="9512e-116">Par exemple, considérez le cas de la recherche de Grover avec l’état initial $H ^ {\otimes n} \ket {0} $ et l’État marqué $ \ket{m} $, $P _0 = H ^ {\otimes n} \ket {0} \bra {0} H ^ {\otimes n} $ et $P _ 1 = \ket{m}\bra{m} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="9512e-117">Dans la plupart des applications d’amplification d’amplitude $P _0 $ sera un projecteur dans un état initial signifiant que $P _0 = \boldone-2 \ Ket {\ PSI} \ Bra {\ PSI} $ pour un vecteur $ \ket{\Psi} $; Toutefois, pour oublie amplitude amplication $P _0 $ se projette généralement sur de nombreux États quantiques (c’est-à-dire, la multiplicité de la eigenvalue $ + $1 de $P _0 $ est supérieure à $1 $).</span><span class="sxs-lookup"><span data-stu-id="9512e-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="9512e-118">La logique derrière l’amplification d’amplitude suit directement à partir de la vecteurs-Decomposition de $Q $.</span><span class="sxs-lookup"><span data-stu-id="9512e-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="9512e-119">En particulier, le vecteurs propres de $Q $ pour lequel l’état initial a une prise en charge différente de zéro peut s’afficher comme des combinaisons linéaires du vecteurs propres $ + $1 de $P _0 $ et $P _ 1 $.</span><span class="sxs-lookup"><span data-stu-id="9512e-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="9512e-120">Plus précisément, l’état initial de l’amplification d’amplitude (en supposant qu’il s’agit d’un extraction $ + $1 de $P _0 $) peut être écrit sous la forme $ $ \ket{\Psi} = \frac{-i}{\sqrt {2} } \left (e ^ {i\theta} \ Ket {\ psi_ +} + e ^ {-i\theta} \ Ket {\ psi_-} \right), $ $ where $ \ket{\ psi_ \pm} $ sont vecteurs propres de $Q $ avec valeurs propres $e ^ {\pm 2i \ thêta} $ et ne prennent en charge que sur le $ + $1 vecteurs propres de $P _0 $ et $P 1 1 $.</span><span class="sxs-lookup"><span data-stu-id="9512e-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="9512e-121">Le fait que les valeurs propres sont $e ^ {\pm i \Theta} $ signifie que l’opérateur $Q $ effectue une rotation dans un sous-espace à deux dimensions spécifié par les deux projecteurs et l’état initial où l’angle de rotation est de $2 \ Theta $.</span><span class="sxs-lookup"><span data-stu-id="9512e-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="9512e-122">C’est pourquoi, après $m $ iterations de $Q $, la probabilité de réussite est de $ \sin ^ 2 ([2m + 1] \Theta) $.</span><span class="sxs-lookup"><span data-stu-id="9512e-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="9512e-123">Une autre propriété utile est que le eigenvalue $ \Theta $ est directement lié à la probabilité que l’état initial soit marqué (dans le cas où $P _0 $ est un projecteur sur uniquement l’état initial).</span><span class="sxs-lookup"><span data-stu-id="9512e-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="9512e-124">Étant donné que le eigenphases de $Q $ est égal à $2 \ Theta = 2 \ Sin ^ {-1} (\sqrt{\Pr (Success)}), il suit ensuite que si nous appliquons l’estimation de phase à $Q $, nous pouvons apprendre la probabilité de réussite d’une procédure de Quantum unitaire.</span><span class="sxs-lookup"><span data-stu-id="9512e-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="9512e-125">Cela est utile, car il nécessite que augmentera moins d’applications de la procédure Quantum pour apprendre la probabilité de réussite que cela serait autrement nécessaire.</span><span class="sxs-lookup"><span data-stu-id="9512e-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="9512e-126">:::no-loc(Q#)::: introduit l’amplification d’amplitude comme une spécialisation de l’amplification de l’amplitude oublie.</span><span class="sxs-lookup"><span data-stu-id="9512e-126">:::no-loc(Q#)::: introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="9512e-127">L’amplification oublie amplitude gagne ce moniker car le projecteur sur le eigenspace initial n’a pas besoin d’être un projecteur à l’état initial.</span><span class="sxs-lookup"><span data-stu-id="9512e-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="9512e-128">Dans ce sens, le protocole est oublie à l’état initial.</span><span class="sxs-lookup"><span data-stu-id="9512e-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="9512e-129">L’application clé de l’amplification de l’amplitude oublie est dans certaines *combinaisons linéaires de méthodes de simulation d’unités de* la même manière, où l’état initial est inconnu, mais qui est associé à un registre Ancilla dans le protocole de simulation.</span><span class="sxs-lookup"><span data-stu-id="9512e-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="9512e-130">Si ce registre Ancilla doit être mesuré comme une valeur fixe, par exemple, $0 $, ces méthodes de simulation appliquent la transformation d’unité souhaitée au qubits restant (appelé Registre système).</span><span class="sxs-lookup"><span data-stu-id="9512e-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="9512e-131">Toutefois, tous les autres résultats de mesure provoquent une défaillance.</span><span class="sxs-lookup"><span data-stu-id="9512e-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="9512e-132">L’amplification d’amplitude oublie permet de renforcer la probabilité de réussite de cette mesure à $100 \\ % $ en utilisant le raisonnement ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="9512e-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="9512e-133">En outre, l’amplification d’amplitude ordinaire correspond au cas où le registre système est vide.</span><span class="sxs-lookup"><span data-stu-id="9512e-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="9512e-134">C’est pourquoi :::no-loc(Q#)::: utilise l’amplification d’amplitude oublie comme sous-routine d’amplification d’amplitude fondamentale.</span><span class="sxs-lookup"><span data-stu-id="9512e-134">This is why :::no-loc(Q#)::: uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="9512e-135">La routine générale ( `AmpAmpObliviousByReflectionPhases` ) a deux registres que nous appelons `ancillaRegister` et `systemRegister` .</span><span class="sxs-lookup"><span data-stu-id="9512e-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="9512e-136">Il accepte également deux Oracle pour les réflexions nécessaires.</span><span class="sxs-lookup"><span data-stu-id="9512e-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="9512e-137">Le `ReflectionOracle` agit uniquement sur le `ancillaRegister` , tandis que le `ObliviousOracle` agit conjointement sur les deux registres.</span><span class="sxs-lookup"><span data-stu-id="9512e-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="9512e-138">L’entrée de `ancillaRegister` doit être initialisée à-1 eigenstate du premier opérateur de réflexion $ \boldone-2P_1 $.</span><span class="sxs-lookup"><span data-stu-id="9512e-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="9512e-139">En règle générale, Oracle prépare l’État dans la base de calcul $ \ket{0...0} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="9512e-140">Dans notre implémentation, le est `ancillaRegister` constitué d’un qubit ( `flagQubit` ) qui contrôle le `stateOracle` et le reste du ancillas souhaité.</span><span class="sxs-lookup"><span data-stu-id="9512e-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="9512e-141">`stateOracle`Est appliqué lorsque `flagQubit` est $ \ket {1} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="9512e-142">Vous pouvez également fournir des Oracle `StateOracle` et `ObliviousOracle` non des réflexions à l’aide d’un appel à `AmpAmpObliviousByOraclePhases` .</span><span class="sxs-lookup"><span data-stu-id="9512e-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="9512e-143">Comme nous l’avons vu précédemment, l’amplification d’amplitude traditionnelle n’est qu’un cas particulier de ces routines où `ObliviousOracle` est l’opérateur d’identité et il n’y a pas de qubits système (autrement dit, `systemRegister` est vide).</span><span class="sxs-lookup"><span data-stu-id="9512e-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="9512e-144">Si vous souhaitez obtenir des phases pour les réflexions partielles (par exemple, pour la recherche Grover), la fonction `AmpAmpPhasesStandard` est disponible.</span><span class="sxs-lookup"><span data-stu-id="9512e-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="9512e-145">Reportez-vous à `DatabaseSearch.qs` pour obtenir un exemple d’implémentation de l’algorithme de Grover.</span><span class="sxs-lookup"><span data-stu-id="9512e-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="9512e-146">Nous associons les phases de rotation qubit aux phases de l’opérateur de réflexion, comme décrit dans le document de [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span><span class="sxs-lookup"><span data-stu-id="9512e-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="9512e-147">Les phases à virgule fixe utilisées sont détaillées dans [Yoder, Low et Chuang](https://arxiv.org/abs/1409.3305) , ainsi que les phases dans [Low, Yoder et Chuang](https://arxiv.org/abs/1603.03996).</span><span class="sxs-lookup"><span data-stu-id="9512e-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="9512e-148">Pour l’arrière-plan, vous pouvez commencer à partir de l’amplification de l' [amplitude standard](https://arxiv.org/abs/quant-ph/0005055) , puis passer à une introduction à l’amplification de l' [amplitude oublie](https://arxiv.org/abs/1312.1414) et enfin aux généralisations présentées dans [Low et Chuang](https://arxiv.org/abs/1610.06546).</span><span class="sxs-lookup"><span data-stu-id="9512e-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="9512e-149">Une présentation intéressante de la totalité de cette zone (par opposition à la simulation de Hamilton) a été fournie par [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span><span class="sxs-lookup"><span data-stu-id="9512e-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="9512e-150">Transformation de Fourier quantique</span><span class="sxs-lookup"><span data-stu-id="9512e-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="9512e-151">La transformation de Fourier est un outil fondamental de l’analyse classique et est tout aussi importante pour les calculs Quantum.</span><span class="sxs-lookup"><span data-stu-id="9512e-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="9512e-152">En outre, l’efficacité de la *transformation de Fourier quantique* (QFT) dépasse ce qui est possible sur une machine classique, ce qui en fait un des premiers outils de choix lors de la conception d’un algorithme Quantum.</span><span class="sxs-lookup"><span data-stu-id="9512e-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="9512e-153">En guise de généralisation approximative du QFT, nous fournissons l' <xref:Microsoft.Quantum.Canon.ApproximateQft> opération qui permet d’effectuer d’autres optimisations en élaguant les rotations qui ne sont pas strictement nécessaires pour la précision algorithmique souhaitée.</span><span class="sxs-lookup"><span data-stu-id="9512e-153">As an approximate generalization of the QFT, we provide the <xref:Microsoft.Quantum.Canon.ApproximateQft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="9512e-154">Le QFT approximatif requiert l’opération dyadic $Z $-rotation <xref:Microsoft.Quantum.Intrinsic.RFrac> , ainsi que l' <xref:Microsoft.Quantum.Intrinsic.H> opération.</span><span class="sxs-lookup"><span data-stu-id="9512e-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:Microsoft.Quantum.Intrinsic.RFrac> as well as the <xref:Microsoft.Quantum.Intrinsic.H> operation.</span></span>
<span data-ttu-id="9512e-155">L’entrée et la sortie sont supposées être encodées au format d’encodage Big endian---autrement dit, le qubit avec l’index `0` est encodé dans le bit le plus à gauche (le plus élevé) de la représentation d’entier binaire.</span><span class="sxs-lookup"><span data-stu-id="9512e-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="9512e-156">Cela s’aligne avec la [notation Ket](xref:microsoft.quantum.concepts.dirac), dans la mesure où un registre de trois qubits à l’État $ \ket {100} $ correspond à $q _0 $ se trouve dans l’État $ \ket {1} $ tandis que $q _ 1 $ et $q _2 $ sont tous deux dans l’État $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="9512e-157">Le paramètre approximatif $a $ détermine le niveau de nettoyage des $Z $-rotations, c’est-à-dire $a \Dans [0.. n] $.</span><span class="sxs-lookup"><span data-stu-id="9512e-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="9512e-158">Dans ce cas, tous les $Z $-rotations $2 \ pi/2 ^ k $ où $k > un $ sont supprimés du circuit QFT.</span><span class="sxs-lookup"><span data-stu-id="9512e-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="9512e-159">Il est connu que pour $k \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3.</span><span class="sxs-lookup"><span data-stu-id="9512e-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="9512e-160">vous pouvez lier $ \\ | \operatorname{QFT}-\operatorname{AQFT} \\ | < \epsilon $.</span><span class="sxs-lookup"><span data-stu-id="9512e-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="9512e-161">Ici \\ , $ | \cdot \\ | $ est la norme d’opérateur qui, dans ce cas, correspond à la racine carrée de la plus grande [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) de $ (\operatorname{QFT}-\operatorname{AQFT}) (\operatorname{QFT}-\operatorname{AQFT}) ^ \dagger $.</span><span class="sxs-lookup"><span data-stu-id="9512e-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="9512e-162">Arithmétique</span><span class="sxs-lookup"><span data-stu-id="9512e-162">Arithmetic</span></span> ##

<span data-ttu-id="9512e-163">Tout comme l’arithmétique joue un rôle central dans l’informatique classique, elle est également indispensable dans quantum computing.</span><span class="sxs-lookup"><span data-stu-id="9512e-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="9512e-164">Les algorithmes tels que l’algorithme de factorisation de Shori, les méthodes de simulation quantique et de nombreux algorithmes Oracular s’appuient sur des opérations arithmétiques cohérentes.</span><span class="sxs-lookup"><span data-stu-id="9512e-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="9512e-165">La plupart des approches de la génération arithmétique sur les circuits d’Adder quantique.</span><span class="sxs-lookup"><span data-stu-id="9512e-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="9512e-166">L’Adder le plus simple accepte une entrée classique $b $ et ajoute la valeur à un État Quantum contenant un entier $ \ket{a} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="9512e-167">Mathématiquement, l’Adder (que nous désignerons $ \operatorname{Add} (b) $ pour l’entrée classique $b $) a la propriété qui</span><span class="sxs-lookup"><span data-stu-id="9512e-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="9512e-168">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}.</span><span class="sxs-lookup"><span data-stu-id="9512e-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="9512e-169">$ $ Ce circuit d’Adder de base est plus un incrémenteur qu’un Adder.</span><span class="sxs-lookup"><span data-stu-id="9512e-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="9512e-170">Elle peut être convertie en un Adder qui a deux entrées Quantum via $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}, $ $ à l’aide d’une application $n $ régulée de la forme \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda \_ {a \_ 0} \Left (\operatorname{Add} (1) \Right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (4) \right) \cdots \Lambda \_ {a \_ {n-1}} \left (\operatorname{Add} ({{n-1}}) \right) \ket{a}\ket{b} \\ \\ & = \ket{a} \ket{b + a}, \end{align} pour $n entiers $ bits $a $ et $b $ et addition modulo $2 ^ n $.</span><span class="sxs-lookup"><span data-stu-id="9512e-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="9512e-171">Rappelez-vous que la notation $ \Lambda \_ x (A) $ fait référence, pour toute opération $A $, à la version contrôlée de cette opération avec le contrôle qubit $x $ As.</span><span class="sxs-lookup"><span data-stu-id="9512e-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="9512e-172">De même, une multiplication contrôlée de manière classique (une forme modulaire de qui est essentielle pour l’algorithme de factorisation de Shori) peut être effectuée à l’aide d’une série similaire d’ajouts contrôlés : \begin{align} \operatorname{Mult} (a) \ket{x}\ket{b} & = \Lambda \_ {x \_ 0} \Left (\operatorname{Add} (2 ^ 0 a) \right) \Lambda \_ {a \_ 1} \left (\operatorname{Add} (2 ^ 1a) \right) \Lambda \_ {a \_ 2} \left (\operatorname{Add} (2 ^ 2 a) \right) \cdots \Lambda \_ {x \_ {n-1}} \left (\operatorname{Add} ({2 ^ {n-1}} a) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + ax}.</span><span class="sxs-lookup"><span data-stu-id="9512e-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="9512e-173">\end{align} il existe une subtilité avec multiplication sur les ordinateurs quantiques que vous pouvez remarquer à partir de la définition de $ \operatorname{Mult} $ ci-dessus.</span><span class="sxs-lookup"><span data-stu-id="9512e-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="9512e-174">Contrairement à l’addition, la version Quantum de ce circuit stocke le produit des entrées dans un registre accessoire plutôt que dans le registre d’entrée.</span><span class="sxs-lookup"><span data-stu-id="9512e-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="9512e-175">Dans cet exemple, le Registre est initialisé avec la valeur $b $, mais il commence généralement à contenir la valeur zéro.</span><span class="sxs-lookup"><span data-stu-id="9512e-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="9512e-176">Cela est nécessaire dans, car en général, il n’y a pas d’inverse multiplicatif pour général $a $ et $x $.</span><span class="sxs-lookup"><span data-stu-id="9512e-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="9512e-177">Étant donné que toutes les opérations de Quantum, enregistrer les mesures, sont réversibles, nous devons conserver suffisamment d’informations pour inverser la multiplication.</span><span class="sxs-lookup"><span data-stu-id="9512e-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="9512e-178">Pour cette raison, le résultat est stocké dans un tableau séparé.</span><span class="sxs-lookup"><span data-stu-id="9512e-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="9512e-179">Cette astuce d’enregistrement de la sortie d’une opération irréversible, comme la multiplication, dans un registre distinct, est appelée « Astuce Bennett » après Charlie Bennett et est un outil fondamental dans le calcul réversible et le traitement quantique.</span><span class="sxs-lookup"><span data-stu-id="9512e-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="9512e-180">De nombreux circuits quantiques ont été proposés pour l’ajout et chacun d’entre eux explore un autre compromis en termes de nombre d’qubits (espace) et le nombre d’opérations de la porte (Time) requises.</span><span class="sxs-lookup"><span data-stu-id="9512e-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="9512e-181">Nous examinons deux ajouts de plus en plus d’espace sous le nom d’Adder Draper et l’Adder Beauregard.</span><span class="sxs-lookup"><span data-stu-id="9512e-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="9512e-182">Draper Adder</span><span class="sxs-lookup"><span data-stu-id="9512e-182">Draper Adder</span></span> ###

<span data-ttu-id="9512e-183">L’Adder Draper est sans doute l’un des compléments quantiques les plus élégants, car il appelle directement les propriétés Quantum pour effectuer l’addition.</span><span class="sxs-lookup"><span data-stu-id="9512e-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="9512e-184">L’idée de l’Adder Draper est que la transformation de Fourier peut être utilisée pour convertir les décalages de phase en un décalage binaire.</span><span class="sxs-lookup"><span data-stu-id="9512e-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="9512e-185">Il suit ensuite cela en appliquant une transformation de Fourier, en appliquant des décalages de phase appropriés, puis en annulant la transformation de Fourier, vous pouvez implémenter un Adder.</span><span class="sxs-lookup"><span data-stu-id="9512e-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="9512e-186">Contrairement à de nombreux autres ajouts qui ont été proposés, l’Adder Draper utilise explicitement les effets Quantum introduits via la transformation de Fourier quantique.</span><span class="sxs-lookup"><span data-stu-id="9512e-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="9512e-187">Elle n’a pas d’équivalent classique naturel.</span><span class="sxs-lookup"><span data-stu-id="9512e-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="9512e-188">Les étapes spécifiques de l’Adder Draper sont indiquées ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="9512e-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="9512e-189">Supposons que vous disposez de deux $n des registres qubit $-bit qui stockent les entiers $a $ et $b $ pour tous les $a $ $ $ \operatorname{QFT}\ket{a} = \frac {1} {\sqrt{2 ^ n}} \sum \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (AJ)/2 ^ n} \ket{j}.</span><span class="sxs-lookup"><span data-stu-id="9512e-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="9512e-190">$ $ Si nous définissons $ $ \ket{\Phi \_ k (a)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi a/2 ^ k} \ket \right {1} ), $ $ Then après une algèbre, vous pouvez voir que $ $ \operatorname{QFT}\ket{a} = \ket{\Phi \_ 1 (a)} \otimes \cdots \otimes \ket{\Phi \_ n (a)}.</span><span class="sxs-lookup"><span data-stu-id="9512e-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="9512e-191">$ $ Le chemin vers l’exécution d’un Adder devient clair après avoir observé que la somme des entrées peut être écrite sous la forme $ $ \ket{a + b} = \operatorname{QFT} ^ {-1} \ket{\Phi \_ 1 (a + b)} \otimes \cdots \otimes \ket{\Phi \_ n (a + b)}.</span><span class="sxs-lookup"><span data-stu-id="9512e-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="9512e-192">$ $ Les entiers $b $ et $a $ peuvent ensuite être ajoutés en effectuant une rotation en phase contrôlée sur chaque qubits de la décomposition en utilisant les bits de $b $ comme contrôles.</span><span class="sxs-lookup"><span data-stu-id="9512e-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="9512e-193">Cette expansion peut être simplifiée en notant que pour tout entier $j $ et nombre réel $x $, $e ^ {i2\pi (x + j)} = e ^ {i2\pi x} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="9512e-194">Cela est dû au fait que si vous faites pivoter $360 ^ {\circ} $ degrees ($ 2 \ pi $ radians) dans un cercle, vous obtenez précisément l’emplacement où vous avez commencé.</span><span class="sxs-lookup"><span data-stu-id="9512e-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="9512e-195">La seule partie importante de $x $ pour $e ^ {i2\pi x} $ est donc la partie fractionnaire de $x $.</span><span class="sxs-lookup"><span data-stu-id="9512e-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="9512e-196">Plus précisément, si nous avons une expansion binaire de la forme $x = y +0. x \_ 0x \_ 2 \ ldots x \_ n $ Then $e ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ ldots x \_ {n-1})} $ et donc $ $ \ket{\Phi \_ k (a + b)} = \frac {1} {\sqrt {2} } \left (\ket {0} + e ^ {i2\pi [a/2 ^ k +0. b \_ K\ldots b \_ 1]} \ket {1} \right). $ $ cela signifie que si nous effectuons l’addition en incrémentant chacun des facteurs tenseur dans l’expansion de la transformation de Fourier de la permutation de $ \ket{a} $, le nombre de rotations diminue à mesure que $k $ diminue.</span><span class="sxs-lookup"><span data-stu-id="9512e-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="9512e-197">Cela réduit considérablement le nombre de portes de Quantum nécessaires dans l’Adder.</span><span class="sxs-lookup"><span data-stu-id="9512e-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="9512e-198">Nous dénotarons la transformation de Fourier, l’ajout de phase et les étapes de transformation de Fourier inverse qui composent l’Adder Draper en tant que $ \operatorname{QFT} ^ {-1} \left (\Phi \\ \! \operatorname{Add}\right) \operatorname{QFT} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="9512e-199">Un circuit quantique qui utilise cette simplification pour implémenter l’ensemble du processus peut être consulté ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="9512e-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![Draper Adder affiché sous forme de diagramme de circuit](~/media/draper.svg)

<span data-ttu-id="9512e-201">Chaque porte contrôlée $e ^ {I2 \ pi/k} $ dans le circuit fait référence à une porte de phase contrôlée.</span><span class="sxs-lookup"><span data-stu-id="9512e-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="9512e-202">Ces portes ont la propriété qui se trouve sur la paire de qubits sur laquelle elles agissent, $ \ket {00} \mapsto \ket {00} $ mais $ \ket {11} \mapsto e ^ {I2 \ pi/k} \ Ket {11} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="9512e-203">Ce circuit nous permet d’effectuer une addition à l’aide d’un qubits supplémentaire, à l’exception de ceux qui sont nécessaires pour stocker les entrées et les sorties.</span><span class="sxs-lookup"><span data-stu-id="9512e-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="9512e-204">Beauregard Adder</span><span class="sxs-lookup"><span data-stu-id="9512e-204">Beauregard Adder</span></span> ###

<span data-ttu-id="9512e-205">L’Adder Beauregard est un Adder modulaire quantique qui utilise l’Adder Draper pour effectuer l’addition de modulo $N $ pour un entier positif de valeur arbitraire $N $.</span><span class="sxs-lookup"><span data-stu-id="9512e-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="9512e-206">L’importance des compléments modulaires quantiques, tels que l’Beauregard Adder, est importante dans une large mesure de leur utilisation dans l’étape d’élévation modulaire de l’algorithme de Shori pour la factorisation.</span><span class="sxs-lookup"><span data-stu-id="9512e-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="9512e-207">Un Adder modulaire Quantum a l’action suivante pour l’entrée Quantum $ \ket{b} $ et l’entrée classique $a $ où $a $ et $b $ sont promis d’être des entiers mod $N $, ce qui signifie qu’ils se trouvent dans l’intervalle $ [0, \ldots, N-1] $.</span><span class="sxs-lookup"><span data-stu-id="9512e-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="9512e-208">$ $ \ket{b}\rightarrow \ket{b + a \text{mod} N} = \begin{cases} \ket{b + a}, & b + a < N \\ \\ \ket{b + a-n}, & (b + a) \ge n \end{cases}.</span><span class="sxs-lookup"><span data-stu-id="9512e-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="9512e-209">L’Adder Beauregard utilise l’Adder Draper, ou plus spécifiquement $ \Phi \\ \! \operatorname{Add} $, pour ajouter $a $ et $b $ en phase.</span><span class="sxs-lookup"><span data-stu-id="9512e-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="9512e-210">Il utilise ensuite la même opération pour déterminer si $a + b <N $ en soustrayant $N $ et en testant si $a + b-N<$0.</span><span class="sxs-lookup"><span data-stu-id="9512e-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="9512e-211">Le circuit stocke ces informations dans un qubit auxiliaire, puis ajoute $N $ Back au Registre si $a + b<N $.</span><span class="sxs-lookup"><span data-stu-id="9512e-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="9512e-212">Il conclut ensuite en décalculant ce bit accessoire (cette étape est nécessaire pour s’assurer que le Ancilla peut être désalloué après l’appel de l’Adder).</span><span class="sxs-lookup"><span data-stu-id="9512e-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="9512e-213">Le circuit de l’Adder Beauregard est indiqué ci-dessous.</span><span class="sxs-lookup"><span data-stu-id="9512e-213">The circuit for the Beauregard adder is given below.</span></span>

![Beauregard Adder affiché sous forme de diagramme de circuit](~/media/beau.svg)

<span data-ttu-id="9512e-215">Ici, la porte $ \Phi \\ \! \operatorname{Add} $ prend la même forme que $ \Phi \\ \! \operatorname{Add} $, sauf que dans ce contexte, l’entrée est classique plutôt que Quantum.</span><span class="sxs-lookup"><span data-stu-id="9512e-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="9512e-216">Cela permet de remplacer les phases contrôlées dans $ \Phi \\ \! \operatorname{Add} $ par les portes de phase qui peuvent ensuite être compilées en moins d’opérations pour réduire à la fois le nombre de qubits et le nombre de portes nécessaires pour l’Adder.</span><span class="sxs-lookup"><span data-stu-id="9512e-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="9512e-217">Pour plus d’informations, consultez [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) et [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span><span class="sxs-lookup"><span data-stu-id="9512e-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="9512e-218">Estimation des phases quantiques</span><span class="sxs-lookup"><span data-stu-id="9512e-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="9512e-219">Une application particulièrement importante de la transformation de Fourier quantique consiste à apprendre le valeurs propres d’opérateurs unitaires, un problème connu sous le nom d' *estimation de phase* .</span><span class="sxs-lookup"><span data-stu-id="9512e-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation* .</span></span>
<span data-ttu-id="9512e-220">Imaginez un $U unitaire $ et un État $ \ket{\Phi} $, de sorte que $ \ket{\Phi} $ est un eigenstate de $U $ avec eigenvalue $ \Phi $, \begin{Equation} U\ket {\ Phi} = \phi\ket{\Phi}. inconnu.</span><span class="sxs-lookup"><span data-stu-id="9512e-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="9512e-221">\end{Equation} si nous avons uniquement accès à $U $ en tant qu’Oracle, nous pouvons apprendre la phase $ \Phi $ en utilisant que $Z $ rotations appliqué à la cible d’une opération contrôlée se propage à nouveau sur le contrôle.</span><span class="sxs-lookup"><span data-stu-id="9512e-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="9512e-222">Supposons que $V $ est une application contrôlée de $U $, telle que \begin{align} V (\ket {0} \otimes \ket{\Phi}) & = \ket \otimes \ket{\Phi} \textrm{ {0} \\ \\ et} V (\ket {1} \otimes \ket{\Phi}) & = e ^ {i \Phi} {1} \ket \otimes \ket{\Phi}.</span><span class="sxs-lookup"><span data-stu-id="9512e-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="9512e-223">\end{align} ensuite, par linéarité, \begin{align} V (\ket{+} \otimes \ket{\Phi}) & = \frac{(\ket {0} \otimes \ket{\Phi}) + e ^ {\Phi} (\ket {1} \otimes \ket{\Phi})} {\sqrt {2} }.</span><span class="sxs-lookup"><span data-stu-id="9512e-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="9512e-224">\end{align}, nous pouvons collecter des termes pour déterminer que \begin{align} V (\ket{+} \otimes \ket{\Phi}) & = \frac{\ket {0} + e ^ {i \Phi} \ket {1} } {\sqrt {2} } \otimes \ket{\Phi} \\ \\ & = (R_1 (\Phi) \ket{+}) \otimes \ket{\Phi}, \end{align} où $R 1 à 1 est l’unité appliquée par l' <xref:Microsoft.Quantum.Intrinsic.R1> opération.</span><span class="sxs-lookup"><span data-stu-id="9512e-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:Microsoft.Quantum.Intrinsic.R1> operation.</span></span>
<span data-ttu-id="9512e-225">Autrement dit, l’effet de l’application de $V $ est précisément identique à l’application de $R 1 _ 1 $ avec un angle inconnu, même si nous n’avons accès qu’à $V $ en tant qu’Oracle.</span><span class="sxs-lookup"><span data-stu-id="9512e-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="9512e-226">Ainsi, dans le reste de cette discussion, nous aborderons l’estimation de phase en termes de $R _ 1 (\Phi) $, que nous implémentons à l’aide de la *phase Kickback* .</span><span class="sxs-lookup"><span data-stu-id="9512e-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback* .</span></span>

<span data-ttu-id="9512e-227">Dans la mesure où le contrôle et le registre cible ne sont pas transformés après ce processus, nous pouvons réutiliser $ \ket{\Phi} $ comme cible d’une application contrôlée de $U ^ $2 pour préparer un deuxième qubit de contrôle à l’état $R _ 1 (2 \Phi) \ket{+} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="9512e-228">En continuant ainsi, nous pouvons obtenir un registre au format \begin{align} \ket{\Psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \Phi) \ket{+} \\ \\ & \propto \ bigotimes_ {j = 0} ^ {n} \left (\ket {0} + \exp (i 2 ^ {j} \Phi) \ket {1} \right) \\ \\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align} où $n $ est le nombre de bits de précision dont nous avons besoin. et où nous avons utilisé $ {} \propto {} $ pour indiquer que nous avons supprimé le facteur de normalisation de $1/\sqrt{2 ^ n} $.</span><span class="sxs-lookup"><span data-stu-id="9512e-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="9512e-229">Si nous supposons que $ \Phi = 2 \pi p/2 ^ k $ pour un entier $p $, nous le reconnaissons comme $ \ket{\Psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n} $, où $p _J $ est le $j ^ {\textrm{th}} $ bit de $2 \pi \Phi $.</span><span class="sxs-lookup"><span data-stu-id="9512e-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="9512e-230">En appliquant le voisin de la transformation de Fourier quantique, nous obtenons donc la représentation binaire de la phase encodée comme un État Quantum.</span><span class="sxs-lookup"><span data-stu-id="9512e-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="9512e-231">Dans :::no-loc(Q#)::: , il est implémenté par l' <xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation> opération, qui prend une <xref:Microsoft.Quantum.Oracles.DiscreteOracle> application d’implémentation de $U ^ m $ comme fonction des entiers positifs $m $.</span><span class="sxs-lookup"><span data-stu-id="9512e-231">In :::no-loc(Q#):::, this is implemented by the <xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation> operation, which takes a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
