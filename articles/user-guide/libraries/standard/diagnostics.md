---
title: 'Diagnostics dans les Q# bibliothèques standard'
description: 'Découvrez les fonctions et opérations de diagnostic dans les Q# bibliothèques standard utilisées pour détecter les erreurs ou les erreurs dans les programmes Quantum.'
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad
ms.topic: article
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 1ab9b77c7536a1860064110810371d3a68e95b40
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 10/27/2020
ms.locfileid: "92690857"
---
# <a name="diagnostics"></a><span data-ttu-id="39d7f-103">Diagnostics</span><span class="sxs-lookup"><span data-stu-id="39d7f-103">Diagnostics</span></span> #

<span data-ttu-id="39d7f-104">Comme pour le développement classique, il est important de pouvoir diagnostiquer les erreurs et les erreurs dans les programmes Quantum.</span><span class="sxs-lookup"><span data-stu-id="39d7f-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="39d7f-105">Les Q# bibliothèques standard offrent différentes méthodes pour garantir l’exactitude des programmes Quantum, comme indiqué dans <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="39d7f-105">The Q# standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="39d7f-106">En grande partie, cette prise en charge est fournie sous la forme de fonctions et d’opérations qui demandent à l’ordinateur cible de fournir des informations de diagnostic supplémentaires au programme hôte ou au développeur, ou d’appliquer l’exactitude des conditions et invariants exprimées par la fonction ou l’appel d’opération.</span><span class="sxs-lookup"><span data-stu-id="39d7f-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="39d7f-107">Diagnostics de l’ordinateur</span><span class="sxs-lookup"><span data-stu-id="39d7f-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="39d7f-108">Les diagnostics sur les valeurs classiques peuvent être obtenus à l’aide de la <xref:Microsoft.Quantum.Intrinsic.Message> fonction pour enregistrer un message selon une méthode dépendante de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="39d7f-108">Diagnostics about classical values can be obtained by using the <xref:Microsoft.Quantum.Intrinsic.Message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="39d7f-109">Par défaut, cette valeur écrit la chaîne dans la console.</span><span class="sxs-lookup"><span data-stu-id="39d7f-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="39d7f-110">Utilisé avec les chaînes interpolées, permet <xref:Microsoft.Quantum.Intrinsic.Message> de signaler facilement les informations de diagnostic sur les valeurs classiques :</span><span class="sxs-lookup"><span data-stu-id="39d7f-110">Used together with interpolated strings, <xref:Microsoft.Quantum.Intrinsic.Message> makes it easy to report diagnostic information about classical values:</span></span>

```Q#
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="39d7f-111">`Message` possède `(String -> Unit)` une signature, indiquant de nouveau que l’émission d’un message du journal de débogage ne peut pas être observée à partir de Q# .</span><span class="sxs-lookup"><span data-stu-id="39d7f-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within Q#.</span></span>

<span data-ttu-id="39d7f-112">Les <xref:Microsoft.Quantum.Diagnostics.DumpMachine> <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables et indiquent aux machines cibles de fournir des informations de diagnostic sur tous les qubits actuellement alloués ou sur un registre spécifique de qubits, respectivement.</span><span class="sxs-lookup"><span data-stu-id="39d7f-112">The <xref:Microsoft.Quantum.Diagnostics.DumpMachine> and <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="39d7f-113">Chaque ordinateur cible varie selon les informations de diagnostic fournies en réponse à une instruction de vidage.</span><span class="sxs-lookup"><span data-stu-id="39d7f-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="39d7f-114">L’ordinateur cible du [simulateur d’état complet](xref:microsoft.quantum.machines.full-state-simulator) , par exemple, fournit au programme hôte le vecteur d’État qu’il utilise en interne pour représenter un registre de qubits.</span><span class="sxs-lookup"><span data-stu-id="39d7f-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="39d7f-115">Par comparaison, la machine cible du [simulateur Toffoli](xref:microsoft.quantum.machines.toffoli-simulator) fournit un seul bit classique pour chaque qubit.</span><span class="sxs-lookup"><span data-stu-id="39d7f-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="39d7f-116">Pour en savoir plus sur la sortie [du simulateur d’état complet](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` , jetez un coup d’œil à la section relative aux fonctions de vidage de notre article sur le [test et le débogage](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span><span class="sxs-lookup"><span data-stu-id="39d7f-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="39d7f-117">Faits et assertions</span><span class="sxs-lookup"><span data-stu-id="39d7f-117">Facts and Assertions</span></span> ##

<span data-ttu-id="39d7f-118">Comme indiqué dans [test et débogage](xref:microsoft.quantum.guide.testingdebugging), une fonction ou une opération avec signature `Unit -> Unit` ou `Unit => Unit` , respectivement, peut être marquée comme un *test unitaire* .</span><span class="sxs-lookup"><span data-stu-id="39d7f-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test* .</span></span>
<span data-ttu-id="39d7f-119">Chaque test unitaire se compose généralement d’un petit programme Quantum, avec une ou plusieurs conditions qui vérifient l’exactitude de ce programme.</span><span class="sxs-lookup"><span data-stu-id="39d7f-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="39d7f-120">Ces conditions peuvent se présenter sous la forme de _faits_ , qui vérifient les valeurs de leurs entrées, ou _assertions_ , qui vérifient les États d’un ou plusieurs qubits passés comme entrée.</span><span class="sxs-lookup"><span data-stu-id="39d7f-120">These conditions can come in the form of either _facts_ , which check the values of their inputs, or _assertions_ , which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="39d7f-121">Par exemple, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` représente le fait mathématique que $1 + 1 = $2, tandis que `AssertQubit(One, qubit)` représente la condition selon laquelle la mesure `qubit` renverra un `One` avec certitude.</span><span class="sxs-lookup"><span data-stu-id="39d7f-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="39d7f-122">Dans le premier cas, nous pouvons vérifier l’exactitude de la condition en fonction de ses valeurs, tandis que dans ce dernier, nous devons connaître l’état du qubit afin d’évaluer l’assertion.</span><span class="sxs-lookup"><span data-stu-id="39d7f-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="39d7f-123">Les Q# bibliothèques standard fournissent différentes fonctions pour représenter des faits, notamment :</span><span class="sxs-lookup"><span data-stu-id="39d7f-123">The Q# standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:Microsoft.Quantum.Diagnostics.Fact>
- <xref:Microsoft.Quantum.Diagnostics.EqualityWithinToleranceFact>
- <xref:Microsoft.Quantum.Diagnostics.NearEqualityFactC>
- <xref:Microsoft.Quantum.Diagnostics.EqualityFactI>


### <a name="testing-qubit-states"></a><span data-ttu-id="39d7f-124">Test des États qubit</span><span class="sxs-lookup"><span data-stu-id="39d7f-124">Testing Qubit States</span></span> ###

<span data-ttu-id="39d7f-125">Dans la pratique, les assertions reposent sur le fait que les simulations classiques de mécanismes quantiques n’ont pas besoin de respecter le principe de [non-clonage](https://arxiv.org/abs/quant-ph/9607018), de sorte que nous pouvons effectuer des mesures et des assertions inphysiques lors de l’utilisation d’un simulateur pour notre ordinateur cible.</span><span class="sxs-lookup"><span data-stu-id="39d7f-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="39d7f-126">Par conséquent, nous pouvons tester des opérations individuelles sur un simulateur classique avant de procéder au déploiement sur le matériel.</span><span class="sxs-lookup"><span data-stu-id="39d7f-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="39d7f-127">Sur les ordinateurs cibles qui n’autorisent pas l’évaluation des assertions, les appels à <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> peuvent être ignorés sans risque.</span><span class="sxs-lookup"><span data-stu-id="39d7f-127">On target machines which do not allow evaluation of assertions, calls to <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> can be safely ignored.</span></span>

<span data-ttu-id="39d7f-128">Plus généralement, l' <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> opération déclare que la mesure de la qubits donnée dans la base Pauli donnée aura toujours le résultat donné.</span><span class="sxs-lookup"><span data-stu-id="39d7f-128">More generally, the <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="39d7f-129">Si l’assertion échoue, l’exécution se termine en appelant `fail` avec le message donné.</span><span class="sxs-lookup"><span data-stu-id="39d7f-129">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="39d7f-130">Par défaut, cette opération n’est pas implémentée. les simulateurs qui peuvent prendre en charge le service informatique doivent fournir une implémentation qui effectue la vérification de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="39d7f-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="39d7f-131">`AssertMeasurement` a une signature `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="39d7f-131">`AssertMeasurement` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="39d7f-132">Étant donné que `AssertMeasurement` est une fonction avec un tuple vide comme type de sortie, aucun effet à partir de n' `AssertMeasurement` est observable dans un Q# programme.</span><span class="sxs-lookup"><span data-stu-id="39d7f-132">Since `AssertMeasurement` is a function with an empty tuple as its output type, no effects from having called `AssertMeasurement` are observable within a Q# program.</span></span>

<span data-ttu-id="39d7f-133">La <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> fonction d’opération déclare que la mesure du qubits donné dans la base Pauli donnée aura le résultat donné avec la probabilité donnée, dans une certaine tolérance.</span><span class="sxs-lookup"><span data-stu-id="39d7f-133">The <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="39d7f-134">La tolérance est additive (par exemple, `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="39d7f-134">Tolerance is additive (for example, `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="39d7f-135">Si l’assertion échoue, l’exécution se termine en appelant `fail` avec le message donné.</span><span class="sxs-lookup"><span data-stu-id="39d7f-135">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="39d7f-136">Par défaut, cette opération n’est pas implémentée. les simulateurs qui peuvent prendre en charge le service informatique doivent fournir une implémentation qui effectue la vérification de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="39d7f-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="39d7f-137">`AssertMeasurementProbability` a une signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="39d7f-137">`AssertMeasurementProbability` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="39d7f-138">Le premier `Double` paramètre donne la probabilité souhaitée du résultat, et le deuxième la tolérance.</span><span class="sxs-lookup"><span data-stu-id="39d7f-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="39d7f-139">Nous pouvons faire plus que déclarer une mesure unique, en utilisant le fait que les informations classiques utilisées par un simulateur pour représenter l’état interne d’un qubit sont susceptibles d’être copiées, de sorte que nous n’avons pas besoin d’effectuer une mesure pour tester notre assertion.</span><span class="sxs-lookup"><span data-stu-id="39d7f-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="39d7f-140">En particulier, cela nous permet d’obtenir des informations sur les mesures *incompatibles* qui seraient impossibles sur le matériel réel.</span><span class="sxs-lookup"><span data-stu-id="39d7f-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="39d7f-141">Supposons que `P : Qubit => Unit` est une opération destinée à préparer l’État $ \ket{\Psi} $ quand son entrée est dans l’État $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="39d7f-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="39d7f-142">Let $ \ket{\Psi'} $ est l’état réel préparé par `P` .</span><span class="sxs-lookup"><span data-stu-id="39d7f-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="39d7f-143">Ensuite, $ \ket{\Psi} = \ket{\Psi'} $ si et seulement si la mesure de $ \ket{\Psi'} $ dans l’axe décrit par $ \ket{\Psi} $ retourne toujours `Zero` .</span><span class="sxs-lookup"><span data-stu-id="39d7f-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="39d7f-144">Autrement dit, \begin{align} \ket{\Psi} = \ket{\Psi'} \text{si et seulement si} \braket{\Psi | \Psi'} = 1.</span><span class="sxs-lookup"><span data-stu-id="39d7f-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="39d7f-145">\end{align} à l’aide des opérations primitives définies dans le préambule destiné à, nous pouvons effectuer directement une mesure qui retourne `Zero` si $ \ket{\Psi} $ est un eigenstate de l’un des opérateurs Pauli.</span><span class="sxs-lookup"><span data-stu-id="39d7f-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="39d7f-146">L’opération <xref:Microsoft.Quantum.Diagnostics.AssertQubit> fournit un raccourci particulièrement utile pour le faire dans le cas où nous souhaitons tester l’assertion $ \ket{\Psi} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="39d7f-146">The operation <xref:Microsoft.Quantum.Diagnostics.AssertQubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="39d7f-147">C’est souvent le cas, par exemple, lorsque nous avons non calculé pour retourner Ancilla qubits à $ \ket {0} $ avant de les libérer.</span><span class="sxs-lookup"><span data-stu-id="39d7f-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="39d7f-148">L’assertion de $ \ket {0} $ est également utile lorsque vous souhaitez déclarer que deux opérations de préparation et de préparation d’état `P` `Q` préparent le même État et lorsque `Q` prend en charge `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="39d7f-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="39d7f-149">En particulier,</span><span class="sxs-lookup"><span data-stu-id="39d7f-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="39d7f-150">En général, toutefois, nous ne pouvons pas avoir accès à des assertions sur les États qui ne coïncident pas avec les eigenstates d’opérateurs Pauli.</span><span class="sxs-lookup"><span data-stu-id="39d7f-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="39d7f-151">Par exemple, $ \ket{\Psi} = (\ket {0} + e ^ {i \pi/8} \ket {1} )/\sqrt {2} $ n’est pas une eigenstate d’un opérateur Pauli, de sorte que nous ne pouvons pas utiliser <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> pour déterminer de façon unique qu’un État $ \ket{\Psi'} $ est égal à $ \ket{\Psi} $.</span><span class="sxs-lookup"><span data-stu-id="39d7f-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="39d7f-152">Au lieu de cela, nous devons décomposer l’assertion $ \ket{\Psi'} = \ket{\Psi} $ en hypothèses qui peuvent être testées directement à l’aide des primitives prises en charge par notre simulateur.</span><span class="sxs-lookup"><span data-stu-id="39d7f-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="39d7f-153">Pour ce faire, laissez $ \ket{\Psi} = \alpha \ket {0} + \beta \ket {1} $ pour les nombres complexes $ \alpha = a \_ r + a \_ i et $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="39d7f-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="39d7f-154">Notez que cette expression requiert quatre nombres réels $ \{ a \_ r, a \_ i, b \_ r, b \_ i \} $ pour spécifier, car chaque nombre complexe peut être exprimé comme la somme d’une partie réelle et imaginaire.</span><span class="sxs-lookup"><span data-stu-id="39d7f-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="39d7f-155">En raison de la phase globale, toutefois, nous pouvons choisir $a \_ i = $0, de sorte que nous avons uniquement besoin de trois chiffres réels pour spécifier de manière unique un État à qubit unique.</span><span class="sxs-lookup"><span data-stu-id="39d7f-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="39d7f-156">Par conséquent, nous devons spécifier trois assertions indépendantes les unes des autres afin de déclarer l’État attendu.</span><span class="sxs-lookup"><span data-stu-id="39d7f-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="39d7f-157">Pour ce faire, nous constatons la probabilité d’observer `Zero` pour chaque mesure Pauli en fonction de $ \alpha $ et $ \beta $, et en déclarant chacun séparément.</span><span class="sxs-lookup"><span data-stu-id="39d7f-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="39d7f-158">Autorisez les valeurs $x $, $y $ et $z $ `Result` pour Pauli $X $, $Y $ et $Z $, respectivement.</span><span class="sxs-lookup"><span data-stu-id="39d7f-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="39d7f-159">Puis, à l’aide de la fonction vraisemblance pour les mesures de Quantum, \begin{align} \Pr (x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \Pr (y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ i-a \_ i b \_ r \\ \\ \Pr (z = \texttt{Zero} | \alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + a \_ i ^ 2 + b \_ r ^ 2 + b \_ i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="39d7f-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="39d7f-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="39d7f-160">\end{align}</span></span>

<span data-ttu-id="39d7f-161">L' <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> opération implémente ces assertions à des représentations données de $ \alpha $ et $ \beta $ en tant que valeurs de type <xref:Microsoft.Quantum.Math.Complex> .</span><span class="sxs-lookup"><span data-stu-id="39d7f-161">The <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:Microsoft.Quantum.Math.Complex>.</span></span>
<span data-ttu-id="39d7f-162">Cela est utile lorsque l’État attendu peut être calculé de façon mathématique.</span><span class="sxs-lookup"><span data-stu-id="39d7f-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="39d7f-163">Assertion de l’égalité des opérations de Quantum</span><span class="sxs-lookup"><span data-stu-id="39d7f-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="39d7f-164">Jusqu’ici, nous nous intéressons aux opérations de test qui visent à préparer des États particuliers.</span><span class="sxs-lookup"><span data-stu-id="39d7f-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="39d7f-165">Toutefois, il est souvent intéressant de savoir comment une opération agit pour des entrées arbitraires plutôt que pour une seule entrée fixe.</span><span class="sxs-lookup"><span data-stu-id="39d7f-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="39d7f-166">Supposons, par exemple, que nous ayons implémenté une opération `U : ((Double, Qubit[]) => () : Adjoint)` correspondant à une famille d’opérateurs d’unités $U (t) $ et que vous ayez fourni un `adjoint` bloc explicite au lieu d’utiliser `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="39d7f-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="39d7f-167">Il peut être intéressant de déclarer que $U ^ \dagger (t) = U (-t) $, comme prévu si $t $ représente une heure d’évolution.</span><span class="sxs-lookup"><span data-stu-id="39d7f-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="39d7f-168">En général, il existe deux stratégies différentes que nous pouvons suivre pour faire de l’assertion que deux opérations `U` et `V` agissent de la même manière.</span><span class="sxs-lookup"><span data-stu-id="39d7f-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="39d7f-169">Tout d’abord, nous pouvons vérifier que `U(target); (Adjoint V)(target);` l’option conserve chaque État dans une base donnée.</span><span class="sxs-lookup"><span data-stu-id="39d7f-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="39d7f-170">Deuxièmement, nous pouvons vérifier que `U(target); (Adjoint V)(target);` le fait d’agir à la moitié d’un État enchevêtré préserve Cet enchevêtrement.</span><span class="sxs-lookup"><span data-stu-id="39d7f-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="39d7f-171">Ces stratégies sont implémentées par les opérations Canon <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> et <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced> , respectivement.</span><span class="sxs-lookup"><span data-stu-id="39d7f-171">These strategies are implemented by the canon operations <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> and <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="39d7f-172">L’assertion référencée présentée ci-dessus fonctionne en fonction de l' [Choi – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), une infrastructure mathématique qui lie les opérations sur $n $ qubits aux États enchevêtrés sur $2n $ qubits.</span><span class="sxs-lookup"><span data-stu-id="39d7f-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="39d7f-173">En particulier, l’opération d’identité sur $n $ qubits est représentée par $n $ copies de l’État enchevêtréd $ \ket{\ beta_ {00} } \mathrel{ : =} (\ket {00} + \ket {11} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="39d7f-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="39d7f-174">L’opération <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implémente ce isomorphism, en préparant un État qui représente une opération donnée.</span><span class="sxs-lookup"><span data-stu-id="39d7f-174">The operation <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="39d7f-175">En gros, ces stratégies se distinguent par un compromis d’espace.</span><span class="sxs-lookup"><span data-stu-id="39d7f-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="39d7f-176">L’itération au sein de chaque État d’entrée prend du temps supplémentaire, tandis que l’utilisation de l’enchevêtrement comme référence requiert le stockage de qubits supplémentaires.</span><span class="sxs-lookup"><span data-stu-id="39d7f-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="39d7f-177">Dans les cas où une opération implémente une opération classique réversible, de sorte que nous sommes uniquement intéressés par son comportement sur les États de base de calcul, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> teste l’égalité sur ce jeu restreint d’entrées.</span><span class="sxs-lookup"><span data-stu-id="39d7f-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="39d7f-178">L’itération sur les États d’entrée est gérée par les opérations d’énumération <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> et <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower> .</span><span class="sxs-lookup"><span data-stu-id="39d7f-178">The iteration over input states is handled by the enumeration operations <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> and <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower>.</span></span>
> <span data-ttu-id="39d7f-179">Ces opérations sont plus généralement utiles pour appliquer une opération à chaque élément du produit cartésien entre deux jeux ou plus.</span><span class="sxs-lookup"><span data-stu-id="39d7f-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="39d7f-180">Plus critique, toutefois, les deux approches testent différentes propriétés des opérations en cours d’examen.</span><span class="sxs-lookup"><span data-stu-id="39d7f-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="39d7f-181">Étant donné que l’assertion sur place appelle chaque opération plusieurs fois, une fois pour chaque État d’entrée, les choix aléatoires et les résultats de mesure peuvent changer d’un appel à l’autre.</span><span class="sxs-lookup"><span data-stu-id="39d7f-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="39d7f-182">En revanche, l’assertion référencée appelle chaque opération une seule fois, de telle sorte qu’elle vérifie que les opérations sont égales *dans une seule capture* .</span><span class="sxs-lookup"><span data-stu-id="39d7f-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot* .</span></span>
<span data-ttu-id="39d7f-183">Ces deux tests sont utiles pour garantir l’exactitude des programmes quantiques.</span><span class="sxs-lookup"><span data-stu-id="39d7f-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="39d7f-184">En savoir plus</span><span class="sxs-lookup"><span data-stu-id="39d7f-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:Microsoft.Quantum.Diagnostics>
