---
title: Vue d’ensemble d’un programme Q#
description: Découvrez la structure de base d’un programme Quantum et comment il représente les transformations des États quantiques.
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: 5c75bb5499efac2c49cbfc4555fd15b3e072181c
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907696"
---
# <a name="q-program-overview"></a><span data-ttu-id="3fc9f-103">Vue d’ensemble d’un programme Q#</span><span class="sxs-lookup"><span data-stu-id="3fc9f-103">Q# program overview</span></span>

<span data-ttu-id="3fc9f-104">Q # est un langage de programmation évolutif, à plusieurs paradigmes, spécifique à un domaine pour l’informatique Quantum.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="3fc9f-105">Q # est un langage de programmation Quantum dans la mesure où il peut être utilisé pour décrire comment les instructions sont exécutées sur les machines quantiques.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="3fc9f-106">Les machines qui peuvent être ciblées sont comprises entre les simulateurs et le matériel Quantum réel.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="3fc9f-107">Q # est évolutif : il peut être utilisé pour écrire des programmes de démonstration simples comme la téléchargement qui s’exécutent sur quelques qubits, mais il prend également en charge l’écriture de nombreux programmes sophistiqués, tels que les simulations de molécules complexes, qui nécessitent des machines de grande taille avec des millions de qubits.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="3fc9f-108">Même si les machines physiques volumineuses sont toujours à l’avenir, Q # permet à un programmeur de programmer des algorithmes Quantum complexes.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="3fc9f-109">En plus, Q # prend en charge différentes tâches, telles que le débogage, le profilage, l’estimation des ressources et certaines simulations à usage spécifique de manière évolutive.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="3fc9f-110">D’un point de vue technique, un programme Quantum peut être considéré comme un ensemble particulier de fonctions classiques qui, lorsqu’elles sont appelées, génèrent des circuits quantiques comme des effets secondaires.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="3fc9f-111">Une conséquence importante de cette vue est qu’un programme écrit en Q # ne modélise pas directement qubits, mais décrit plutôt comment un ordinateur de contrôle classique interagit avec ces qubits.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="3fc9f-112">Par défaut, Q # ne définit pas les États quantiques ou d’autres propriétés de la mécanique de Quantum directement, mais le fait indirectement par le biais de l’action des différentes sous-routines définies dans la langue.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="3fc9f-113">Par exemple, considérez l’État $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ abordé dans le guide des concepts de l' [informatique Quantum](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="3fc9f-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="3fc9f-114">Pour préparer cet État dans Q #, nous utilisons les faits que les qubits sont initialisés dans l’État $ \ket{0}$, et que $ \ket{+} = H\ket{0}$, où $H $ est la transformation Hadarmard :</span><span class="sxs-lookup"><span data-stu-id="3fc9f-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="3fc9f-115">Q # tranformations des États de Quantum</span><span class="sxs-lookup"><span data-stu-id="3fc9f-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="3fc9f-116">Important, en écrivant le programme ci-dessus, nous n’avons pas explicitement fait référence à l’État dans Q #, mais nous avons décrit la façon dont l’État a été *transformé* par notre programme.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="3fc9f-117">Ainsi, de la même façon qu’un programme de nuanceur de graphiques accumule une description des transformations à chaque vertex, un programme Quantum dans Q # accumule des transformations à des États quantiques.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="3fc9f-118">Cela nous permet d’être totalement agnostique quant à ce qu' *est* un État Quantum sur chaque ordinateur cible, qui peut avoir des interprétations différentes en fonction de l’ordinateur.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="3fc9f-119">Du point de vue d’un programme Q #, un qubit est une référence entièrement opaque à la structure interne d’un ordinateur cible.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="3fc9f-120">Un programme Q # n’a pas la possibilité d’inverser l’état d’un qubit, sa représentation sur un ordinateur cible, ou même s’il s’agit du même qubit que les autres qubit disponibles pour le programme.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="3fc9f-121">Au lieu de cela, un programme peut appeler des opérations telles que `Measure` pour obtenir des informations à partir d’un qubit et appeler des opérations telles que `X` et `H` pour agir sur l’état d’un qubit.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="3fc9f-122">Ces opérations n’ont pas de définition intrinsèque dans le langage et sont rendues concrètes uniquement par l’ordinateur cible utilisé pour exécuter un programme Q # particulier.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="3fc9f-123">Un programme Q # regroupe ces opérations comme défini par un ordinateur cible pour créer des opérations de niveau supérieur pour exprimer le calcul Quantum.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="3fc9f-124">De cette façon, Q # permet d’exprimer facilement les algorithmes Quantum et hybride Quantum-Classic de la logique, tout en étant également général en ce qui concerne la structure d’un ordinateur cible ou d’un simulateur.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="3fc9f-125">Opérations et fonctions Q #</span><span class="sxs-lookup"><span data-stu-id="3fc9f-125">Q# operations and functions</span></span>

<span data-ttu-id="3fc9f-126">Concrètement, un programme Q # est constitué d’une ou de plusieurs *opérations*, d’une ou plusieurs *fonctions*et de types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="3fc9f-127">Les opérations sont utilisées pour décrire les transformations de l’état d’un ordinateur quantique et constituent le bloc de construction le plus basique des programmes Q #.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="3fc9f-128">Chaque opération définie dans Q # peut alors appeler un nombre quelconque d’autres opérations, y compris les opérations *intrinsèques* intégrées implémentées par un ordinateur cible.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="3fc9f-129">Une fois compilée, chaque opération est représentée sous la forme d’un type de classe .NET qui peut être fourni aux ordinateurs cibles.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="3fc9f-130">Contrairement aux opérations, les fonctions sont utilisées pour décrire le comportement purement classique et n’ont aucun effet en plus des valeurs de sortie classiques.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="3fc9f-131">Q # est un langage fortement typé qui est fourni avec un ensemble de types primitifs intégrés, ainsi que la prise en charge des types définis par l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="3fc9f-132">Dans le reste de ce guide, nous verrons comment utiliser des structures et des concepts de langage différents pour nous aider à définir des programmes quantiques complexes par le biais des blocs de construction de base des opérations, des fonctions et des types.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="3fc9f-133">Structure des fichiers sources Q #</span><span class="sxs-lookup"><span data-stu-id="3fc9f-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="3fc9f-134">Au minimum, un fichier source Q # se compose d’une *déclaration d’espace de noms*, qui spécifie un espace de noms .net qui contiendra les définitions dans le fichier source.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="3fc9f-135">Les définitions d’autres fichiers et bibliothèques source Q # peuvent être incluses à l’aide de l’instruction `open`.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="3fc9f-136">Par exemple, la plupart des opérations qui définissent les portes fondamentales sont définies dans l’espace de noms <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="3fc9f-137">Pour que cela soit possible pour notre code, nous `open` simplement cet espace de noms en haut de chaque fichier :</span><span class="sxs-lookup"><span data-stu-id="3fc9f-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="3fc9f-138">Dans un espace de noms, chaque fichier source Q # peut définir n’importe quelle combinaison d' *opérations*, de *fonctions*et de *types définis par l’utilisateur*.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="3fc9f-139">Dans le reste de cette section, nous décrirons chacun et fournissons des exemples de la façon dont ils peuvent être utilisés dans la pratique pour créer des programmes quantiques utiles.</span><span class="sxs-lookup"><span data-stu-id="3fc9f-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
